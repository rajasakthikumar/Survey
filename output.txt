File: bootstrap.js
----------------------------------------
const SurveyRepository = require('./repositories/survey');
const QuestionRepository = require('./repositories/question');
const AnswerRepository = require('./repositories/answer');
const UserRepository = require('./repositories/user');
const SurveyProgressRepository = require('./repositories/surveyProgress');

const SurveyService = require('./service/survey');
const QuestionService = require('./service/question');
const AnswerService = require('./service/answer');
const UserService = require('./service/user');
const SurveyProgressService = require('./service/surveyProgress');

const SurveyController = require('./controller/survey');
const QuestionController = require('./controller/question');
const AnswerController = require('./controller/answer');
const UserController = require('./controller/user');
const SurveyProgressController = require('./controller/surveyProgress');

// Initialize repositories
const surveyRepository = new SurveyRepository();
const questionRepository = new QuestionRepository();
const answerRepository = new AnswerRepository();
const userRepository = new UserRepository();
const surveyProgressRepository = new SurveyProgressRepository();

const surveyService = new SurveyService(surveyRepository);
const questionService = new QuestionService(questionRepository, surveyService);
surveyService.setQuestionService(questionService);

const userService = new UserService(userRepository);
const surveyProgressService = new SurveyProgressService(
  surveyProgressRepository,
  surveyService,
  questionService
);

const answerService = new AnswerService(answerRepository, questionService, surveyService, surveyProgressService);
const surveyController = new SurveyController(surveyService);
const questionController = new QuestionController(questionService);
const answerController = new AnswerController(answerService);
const userController = new UserController(userService);
const surveyProgressController = new SurveyProgressController(surveyProgressService);

module.exports = {
  surveyController,
  questionController,
  answerController,
  userController,
  surveyProgressController,
};

File: config\keys.js
----------------------------------------
require('dotenv').config();

module.exports = {
  mongoURI: process.env.MONGODB_URI || 'mongodb://localhost:27017/survey',
  jwtSecret: process.env.JWT_SECRET || 'secret',
  port: process.env.PORT || 5000,
  // nodeEnv: process.env.NODE_ENV || 'development'
};

File: controller\answer.js
----------------------------------------
const BaseController = require('./baseController');
const asyncHandler = require('../middleware/asyncHandler');
const formatResponse = require('../utils/formatResponse');


class AnswerController extends BaseController {
    constructor(answerService) {
      super(answerService);
    }
  
    submitAnswer = asyncHandler(async (req, res) => {
      const answer = await this.service.createAnswer({
        ...req.body,
        questionId: req.params.questionId,
        respondentId: req.user.id,
        createdBy: req.user.id
      });
      res.status(201).json(formatResponse(answer));
    });
  
    getAnswersBySurvey = asyncHandler(async (req, res) => {
      const answers = await this.service.getAnswersBySurvey(
        req.params.surveyId,
        req.user.id
      );
      res.status(200).json(formatResponse(answers));
    });
  
    getAnswersByQuestion = asyncHandler(async (req, res) => {
      const answers = await this.service.getAnswersByQuestion(req.params.questionId);
      res.status(200).json(formatResponse(answers));
    });
  
    getMyAnswers = asyncHandler(async (req, res) => {
      const answers = await this.service.getRespondentAnswers(
        req.params.surveyId,
        req.user.id
      );
      res.status(200).json(formatResponse(answers));
    });
  
    getSurveyStats = asyncHandler(async (req, res) => {
      const stats = await this.service.getSurveyStats(req.params.surveyId);
      res.status(200).json(formatResponse(stats));
    });
  
    deleteAnswer = asyncHandler(async (req, res) => {
      await this.service.deleteAnswer(
        req.params.answerId,
        req.user.id,
        req.user.role
      );
      res.status(200).json(formatResponse({ message: 'Answer deleted successfully' }));
    });
  }

module.exports = AnswerController;

File: controller\baseController.js
----------------------------------------
const asyncHandler = require('../middleware/asyncHandler');
const formatResponse = require('../utils/formatResponse');

class BaseController {
  constructor(service) {
    this.service = service;
  }

  getAll = asyncHandler(async (req, res) => {
    const items = await this.service.findAll(req.query);
    res.status(200).json(formatResponse(items));
  });

  getById = asyncHandler(async (req, res) => {
    const item = await this.service.findById(req.params.id);
    res.status(200).json(formatResponse(item));
  });

  create = asyncHandler(async (req, res) => {
    const item = await this.service.create({
      ...req.body,
      createdBy: req.user.id
    });
    res.status(201).json(formatResponse(item));
  });

  update = asyncHandler(async (req, res) => {
    const item = await this.service.updateById(req.params.id, {
      ...req.body,
      modifiedBy: req.user.id
    });
    res.status(200).json(formatResponse(item));
  });

  delete = asyncHandler(async (req, res) => {
    await this.service.deleteById(req.params.id);
    res.status(200).json(formatResponse({ message: 'Resource deleted successfully' }));
  });
}

module.exports = BaseController;

File: controller\question.js
----------------------------------------
const BaseController = require('./baseController');
const asyncHandler = require('../middleware/asyncHandler');
const formatResponse = require('../utils/formatResponse');

class QuestionController extends BaseController {
  constructor(questionService) {
    super(questionService);
  }

  createQuestion = asyncHandler(async (req, res) => {
    console.log('@!@!@!@!@ Control reaches here');
    const question = await this.service.createQuestion({
      ...req.body,
    //   surveyId: req.params.surveyId,
      createdBy: req.user.id
    });
    res.status(201).json(formatResponse(question));
  });

  updateQuestion = asyncHandler(async (req, res) => {
    const question = await this.service.updateQuestion(req.params.id, {
      ...req.body,
      modifiedBy: req.user.id
    });
    res.status(200).json(formatResponse(question));
  });

  moveQuestion = asyncHandler(async (req, res) => {
    const { direction } = req.body;
    const question = await this.service.moveQuestion(
      req.params.surveyId,
      req.params.id,
      direction
    );
    res.status(200).json(formatResponse(question));
  });
}

module.exports = QuestionController;

File: controller\survey.js
----------------------------------------
const BaseController = require('./baseController');
const asyncHandler = require('../middleware/asyncHandler');
const formatResponse = require('../utils/formatResponse');

class SurveyController extends BaseController {
  constructor(surveyService) {
    super(surveyService);
  }

  getAllSurveys = asyncHandler(async (req, res) => {
    if (req.query.includeArchived !== 'true') {
      req.query.isArchived = false;
    }
    delete req.query.includeArchived;

    const surveys = await this.service.getAllSurveys(req.query);
    res.status(200).json(formatResponse(surveys));
  });

  createSurvey = asyncHandler(async (req, res) => {
    const survey = await this.service.createSurvey({
      ...req.body,
      createdBy: req.user.id
    });
    res.status(201).json(formatResponse(survey));
  });

  duplicateSurvey = asyncHandler(async (req, res) => {
    const survey = await this.service.duplicateSurvey(
      req.params.id,
      req.user.id
    );
    res.status(201).json(formatResponse(survey));
  });

  archiveSurvey = asyncHandler(async (req, res) => {
    const survey = await this.service.archiveSurvey(
      req.params.id,
      req.user.id
    );
    res.status(200).json(formatResponse(survey));
  });

  unarchiveSurvey = asyncHandler(async (req, res) => {
    const survey = await this.service.unarchiveSurvey(
      req.params.id,
      req.user.id
    );
    res.status(200).json(formatResponse(survey));
  });

  reorderQuestions = asyncHandler(async (req, res) => {
    const survey = await this.service.reorderQuestions(
      req.params.id,
      req.body.questionOrder
    );
    res.status(200).json(formatResponse(survey));
  });
}

module.exports = SurveyController;

File: controller\surveyProgress.js
----------------------------------------
const BaseController = require('./baseController');
const asyncHandler = require('../middleware/asyncHandler');
const formatResponse = require('../utils/formatResponse');

class SurveyProgressController extends BaseController {
  constructor(surveyProgressService) {
    super(surveyProgressService);
  }

  initializeProgress = asyncHandler(async (req, res) => {
    const progress = await this.service.initializeProgress(
      req.params.surveyId,
      req.user.id
    );
    res.status(200).json(formatResponse(progress));
  });

  updateProgress = asyncHandler(async (req, res) => {
    const progress = await this.service.updateProgress(
      req.params.surveyId,
      req.user.id,
      req.params.questionId
    );
    res.status(200).json(formatResponse(progress));
  });

  getProgress = asyncHandler(async (req, res) => {
    const progress = await this.service.getProgress(
      req.params.surveyId,
      req.user.id
    );
    res.status(200).json(formatResponse(progress));
  });

  getParticipants = asyncHandler(async (req, res) => {
    const participants = await this.service.getSurveyParticipants(
      req.params.surveyId,
      req.user.id
    );
    res.status(200).json(formatResponse(participants));
  });

  getCompletionStats = asyncHandler(async (req, res) => {
    const stats = await this.service.getCompletionStats(
      req.params.surveyId,
      req.user.id
    );
    res.status(200).json(formatResponse(stats));
  });

  getMyProgress = asyncHandler(async (req, res) => {
    const progress = await this.service.getRespondentProgress(req.user.id);
    res.status(200).json(formatResponse(progress));
  });
}

module.exports = SurveyProgressController;

File: controller\user.js
----------------------------------------
const asyncHandler = require('../middleware/asyncHandler');
const formatResponse = require('../utils/formatResponse');

class UserController {
  constructor(userService) {
    this.userService = userService;
  }

  registerUser = asyncHandler(async (req, res, next) => {
    const userData = req.body;
    const { user, token } = await this.userService.registerUser(userData);

    res.status(201).json(formatResponse({ user, token }));
  });

  loginUser = asyncHandler(async (req, res, next) => {
    const userData = req.body;
    const { user, token } = await this.userService.loginUser(userData);

    res.status(200).json(formatResponse({ user, token }));
  });

  getCurrentUser = asyncHandler(async (req, res, next) => {
    const user = await this.userService.getUserById(req.user.id);

    res.status(200).json(formatResponse(user));
  });
}

module.exports = UserController;


File: index.js
----------------------------------------
require('dotenv').config();
const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const helmet = require('helmet');
const keys = require('./config/keys');
const authMiddleware = require('./middleware/auth');
const errorHandler = require('./middleware/errorHandler');

const app = express();

// Middleware
app.use(helmet());
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Database Connection
mongoose
  .connect(keys.mongoURI, {
    useNewUrlParser: true,
    useUnifiedTopology: true,
  })
  .then(() => console.log('MongoDB Connected'))
  .catch((err) => console.error('MongoDB Connection Error:', err));

// Routes
const userRoutes = require('./routes/user');
const surveyRoutes = require('./routes/survey');
const questionRoutes = require('./routes/question');
const answerRoutes = require('./routes/answer');
const surveyProgressRoutes = require('./routes/surveyProgress');

app.use('/api/users', userRoutes);
app.use('/api/surveys', authMiddleware, surveyRoutes);
app.use('/api/questions', authMiddleware, questionRoutes);
app.use('/api/answers', authMiddleware, answerRoutes);
app.use('/api/survey-progress', authMiddleware, surveyProgressRoutes);

// Error Handler
app.use(errorHandler);

const PORT = keys.port;
app.listen(PORT, () => console.log(`Server running on port ${PORT}`));

File: middleware\asyncHandler.js
----------------------------------------
const asyncHandler = fn => (req, res, next) =>
    Promise.resolve(fn(req, res, next)).catch(next);
  
  module.exports = asyncHandler;
  
  

File: middleware\auth.js
----------------------------------------
const jwt = require('jsonwebtoken');
const CustomError = require('../utils/customError');
const keys = require('../config/keys');
const User = require('../models/user');

const protect = async (req, res, next) => {
  try {
    let token;

    if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
      token = req.headers.authorization.split(' ')[1];
    }

    if (!token) {
      throw new CustomError('Not authorized to access this route', 401);
    }

    const decoded = jwt.verify(token, keys.jwtSecret);
    req.user = await User.findById(decoded.id).select('-password');

    if (!req.user) {
      throw new CustomError('User not found', 404);
    }

    next();
  } catch (err) {
    next(new CustomError('Authentication failed', 401));
  }
};

module.exports = protect;

File: middleware\checkOwnership.js
----------------------------------------
const CustomError = require('../utils/customError');

const checkOwnership = (modelName) => async (req, res, next) => {
  const Model = require(`../models/${modelName.toLowerCase()}`);
  const resource = await Model.findById(req.params.id);

  if (!resource) {
    throw new CustomError(`${modelName} not found`, 404);
  }

  if (resource.createdBy.toString() !== req.user.id && req.user.role !== 'admin') {
    throw new CustomError(`Not authorized to modify this ${modelName}`, 403);
  }

  req.resource = resource;
  next();
};

module.exports = checkOwnership;

File: middleware\errorHandler.js
----------------------------------------
const CustomError = require('../utils/customError');

const errorHandler = (err, req, res, next) => {
  let error = { ...err };
  error.message = err.message;

  if (process.env.NODE_ENV === 'test') {
    console.error('Error details:', error);
  }

  if (err.name === 'ValidationError') {
    const message = Object.values(err.errors).map(val => val.message).join(', ');
    error = new CustomError(message, 400);
  }

  if (err.code === 11000) {
    error = new CustomError('Survey with this title already exists', 400);
  }

  res.status(error.statusCode || 500).json({
    success: false,
    error: error.message || 'Server Error'
  });
};

module.exports = errorHandler;

File: middleware\rateLimiter.js
----------------------------------------
const rateLimit = require('express-rate-limit');
const CustomError = require('../utils/customError');

const createRateLimiter = (windowMs, max, message) => {
  return rateLimit({
    windowMs,
    max,
    handler: (req, res) => {
      throw new CustomError(message || 'Too many requests, please try again later', 429);
    }
  });
};

const authLimiter = createRateLimiter(
  15 * 60 * 1000, // 15 minutes
  5,
  'Too many login attempts, please try again after 15 minutes'
);

const apiLimiter = createRateLimiter(
  60 * 1000, // 1 minute
  100,
  'Too many requests, please try again after a minute'
);

module.exports = {
  authLimiter,
  apiLimiter
};

File: middleware\validation.js
----------------------------------------
const Joi = require('joi');
const CustomError = require('../utils/customError');

const validateRequest = (schema) => {
  return (req, res, next) => {
    const { error } = schema.validate(req.body, {
      abortEarly: false,
      stripUnknown: true
    });

    if (error) {
      const errorMessage = error.details
        .map(detail => detail.message)
        .join(', ');
      throw new CustomError(errorMessage, 400);
    }

    next();
  };
};

const schemas = {
  survey: {
    create: Joi.object({
      title: Joi.string()
        .required()
        .max(500)
        .trim()
        .messages({
          'string.empty': 'Title cannot be empty',
          'string.max': 'Title cannot exceed 500 characters'
        }),
      description: Joi.string()
        .allow('')
        .trim(),
      isTemplate: Joi.boolean()
        .default(false)
    }),

    update: Joi.object({
      title: Joi.string()
        .max(500)
        .trim(),
      description: Joi.string()
        .allow('')
        .trim(),
      isTemplate: Joi.boolean(),
      isArchived: Joi.boolean()
    }),

    reorderQuestions: Joi.object({
      questionOrder: Joi.array()
        .items(Joi.string().regex(/^[0-9a-fA-F]{24}$/))
        .required()
        .messages({
          'array.base': 'Question order must be an array',
          'string.pattern.base': 'Invalid question ID format'
        })
    })
  },

  question: {
    create: Joi.object({
      questionText: Joi.string()
        .required()
        .trim()
        .messages({
          'string.empty': 'Question text cannot be empty'
        }),
      responseType: Joi.string()
        .required()
        .valid('text', 'multiple-choice', 'single-choice', 'rating', 'boolean'),
      allowMultiple: Joi.when('responseType', {
        is: 'multiple-choice',
        then: Joi.boolean().required(),
        otherwise: Joi.boolean().valid(false)
      }),
      isMandatory: Joi.boolean()
        .default(false),
      responseValues: Joi.when('responseType', {
        is: Joi.string().valid('multiple-choice', 'single-choice'),
        then: Joi.array()
          .items(Joi.string().required())
          .min(2)
          .required()
          .messages({
            'array.min': 'At least 2 response options are required',
            'array.required': 'Response options are required for choice questions'
          }),
        otherwise: Joi.forbidden()
      })
    }),

    update: Joi.object({
      questionText: Joi.string()
        .trim(),
      isMandatory: Joi.boolean(),
      responseValues: Joi.array()
        .items(Joi.string())
    })
  },

  answer: {
    submit: Joi.object({
      answerValue: Joi.alternatives()
        .try(
          Joi.string(),
          Joi.array().items(Joi.string()),
          Joi.number().min(1).max(5),
          Joi.boolean()
        )
        .required()
        .messages({
          'alternatives.match': 'Invalid answer format for this question type'
        })
    })
  },

  user: {
    register: Joi.object({
      username: Joi.string()
        .required()
        .min(3)
        .max(30)
        .trim()
        .messages({
          'string.min': 'Username must be at least 3 characters',
          'string.max': 'Username cannot exceed 30 characters'
        }),
      email: Joi.string()
        .required()
        .email()
        .messages({
          'string.email': 'Please provide a valid email'
        }),
      password: Joi.string()
        .required()
        .min(6)
        .pattern(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/)
        .messages({
          'string.min': 'Password must be at least 6 characters',
          'string.pattern.base': 'Password must contain at least one uppercase letter, one lowercase letter, and one number'
        })
    }),

    login: Joi.object({
      email: Joi.string()
        .required()
        .email(),
      password: Joi.string()
        .required()
    })
  }
};

module.exports = {
  validateSurvey: validateRequest(schemas.survey.create),
  validateSurveyUpdate: validateRequest(schemas.survey.update),
  validateQuestion: validateRequest(schemas.question.create),
  validateQuestionUpdate: validateRequest(schemas.question.update),
  validateAnswer: validateRequest(schemas.answer.submit),
  validateUserRegister: validateRequest(schemas.user.register),
  validateUserLogin: validateRequest(schemas.user.login),
  validateReorderQuestions: validateRequest(schemas.survey.reorderQuestions)
};

File: models\answer.js
----------------------------------------
const mongoose = require('mongoose');
const { baseModelOptions, baseSchemaFields } = require('./baseModel');

const AnswerSchema = new mongoose.Schema({
  questionId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Question',
    required: true
  },
  surveyId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Survey',
    required: true
  },
  respondentId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  answerValue: {
    type: mongoose.Schema.Types.Mixed,
    required: true
  },
  isValid: {
    type: Boolean,
    default: false
  },
  validatedAt: {
    type: Date
  },
  ...baseSchemaFields
}, baseModelOptions);

AnswerSchema.index({ questionId: 1, respondentId: 1 }, { unique: true });
AnswerSchema.index({ surveyId: 1 });
AnswerSchema.index({ createdAt: 1 });

module.exports = mongoose.model('Answer', AnswerSchema);

File: models\baseModel.js
----------------------------------------
const mongoose = require('mongoose');

const baseModelOptions = {
  timestamps: true,
  toJSON: {
    virtuals: true,
    transform: function(doc, ret) {
      delete ret.__v;
      ret.id = ret._id;
      delete ret._id;
    }
  },
  toObject: {
    virtuals: true,
    transform: function(doc, ret) {
      delete ret.__v;
      ret.id = ret._id;
      delete ret._id;
    }
  }
};

const baseSchemaFields = {
  createdBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: false
  },
  modifiedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: false
  },
  isActive: {
    type: Boolean,
    default: true
  }
};

module.exports = {
  baseModelOptions,
  baseSchemaFields
};

File: models\question.js
----------------------------------------
const mongoose = require('mongoose');
const { baseModelOptions, baseSchemaFields } = require('./baseModel');

const ResponseValueSchema = new mongoose.Schema({
  value: {
    type: String,
    required: [true, 'Please add a response value'],
    trim: true
  },
  order: {
    type: Number,
    default: 0
  }
}, { _id: false });

const QuestionSchema = new mongoose.Schema({
  surveyId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Survey',
    required: true
  },
  questionText: {
    type: String,
    required: [true, 'Please add the question text'],
    trim: true
  },
  responseType: {
    type: String,
    enum: ['text', 'multiple-choice', 'single-choice', 'rating', 'boolean'],
    required: [true, 'Please specify the response type']
  },
  allowMultiple: {
    type: Boolean,
    default: false
  },
  isMandatory: {
    type: Boolean,
    default: false
  },
  order: {
    type: Number,
    required: true
  },
  ...baseSchemaFields
}, baseModelOptions);

// Indexes
QuestionSchema.index({ surveyId: 1, order: 1 });
QuestionSchema.index({ createdBy: 1 });

module.exports = mongoose.model('Question', QuestionSchema);

File: models\survey.js
----------------------------------------
const mongoose = require('mongoose');
const { baseModelOptions, baseSchemaFields } = require('./baseModel');

const SurveySchema = new mongoose.Schema({
  title: {
    type: String,
    required: [true, 'Please add a title'],
    unique: true,
    trim: true,
    maxlength: [500, 'Title cannot exceed 500 characters']
  },
  description: {
    type: String,
    trim: true
  },
  isTemplate: {
    type: Boolean,
    default: false
  },
  isArchived: {
    type: Boolean,
    default: false
  },
  archivedAt: {
    type: Date
  },
  questionOrder: [{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Question'
  }],
  questions: [{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Question'
  }],
  ...baseSchemaFields
}, baseModelOptions);

SurveySchema.index({ title: 1 }, { unique: true });
SurveySchema.index({ createdBy: 1 });
SurveySchema.index({ isArchived: 1 });

module.exports = mongoose.model('Survey', SurveySchema);

File: models\surveyProgress.js
----------------------------------------
const mongoose = require('mongoose');
const { baseModelOptions, baseSchemaFields } = require('./baseModel');

const SurveyProgressSchema = new mongoose.Schema({
  surveyId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Survey',
    required: true
  },
  respondentId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  status: {
    type: String,
    enum: ['NOT_STARTED', 'IN_PROGRESS', 'COMPLETED'],
    default: 'NOT_STARTED'
  },
  startedAt: {
    type: Date
  },
  completedAt: {
    type: Date
  },
  lastAnsweredAt: {
    type: Date
  },
  answeredQuestions: [{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Question'
  }],
  progress: {
    type: Number,
    default: 0,
    min: 0,
    max: 100
  },
  ...baseSchemaFields
}, baseModelOptions);

SurveyProgressSchema.index({ surveyId: 1, respondentId: 1 }, { unique: true });
SurveyProgressSchema.index({ status: 1 });
SurveyProgressSchema.index({ completedAt: 1 });
SurveyProgressSchema.index({ respondentId: 1, status: 1 });

SurveyProgressSchema.pre('save', function(next) {
  if (this.isModified('status')) {
    if (this.status === 'IN_PROGRESS' && !this.startedAt) {
      this.startedAt = new Date();
    } else if (this.status === 'COMPLETED' && !this.completedAt) {
      this.completedAt = new Date();
    }
  }
  if (this.isModified('answeredQuestions')) {
    this.lastAnsweredAt = new Date();
  }
  next();
});

SurveyProgressSchema.methods.isCompleted = function() {
  return this.status === 'COMPLETED';
};

SurveyProgressSchema.methods.isStarted = function() {
  return this.status !== 'NOT_STARTED';
};

module.exports = mongoose.model('SurveyProgress', SurveyProgressSchema);

File: models\user.js
----------------------------------------
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');
const { baseModelOptions } = require('./baseModel');

const UserSchema = new mongoose.Schema({
  username: {
    type: String,
    required: [true, 'Please add a username'],
    unique: true,
    trim: true,
    minlength: [3, 'Username must be at least 3 characters long'],
    maxlength: [30, 'Username cannot exceed 30 characters']
  },
  email: {
    type: String,
    required: [true, 'Please add an email'],
    unique: true,
    trim: true,
    match: [
      /^[\w-]+(\.[\w-]+)*@([\w-]+\.)+[a-zA-Z]{2,7}$/,
      'Please enter a valid email'
    ]
  },
  password: {
    type: String,
    required: [true, 'Please add a password'],
    minlength: [6, 'Password must be at least 6 characters long'],
    select: false // Don't include password by default in queries
  },
  role: {
    type: String,
    enum: ['user', 'admin'],
    default: 'user'
  },
  lastLogin: {
    type: Date
  }
}, baseModelOptions);

// Hash password only when it's modified
UserSchema.pre('save', async function(next) {
  if (!this.isModified('password')) {
    return next();
  }
  
  try {
    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (error) {
    next(error);
  }
});

// Method to compare passwords
UserSchema.methods.matchPassword = async function(enteredPassword) {
  try {
    return await bcrypt.compare(enteredPassword, this.password);
  } catch (error) {
    throw new Error('Error comparing passwords');
  }
};

module.exports = mongoose.model('User', UserSchema);

File: repositories\answer.js
----------------------------------------
const BaseRepository = require('./baseRepository');
const Answer = require('../models/answer');

class AnswerRepository extends BaseRepository {
  constructor() {
    super(Answer);
  }

  async findBySurveyAndRespondent(surveyId, respondentId) {
    return await this.model
      .find({ surveyId, respondentId })
      .populate('questionId');
  }

  async findQuestionAnswers(questionId) {
    return await this.model
      .find({ questionId })
      .populate('respondentId', 'username email');
  }
}

module.exports = AnswerRepository;

File: repositories\baseRepository.js
----------------------------------------
class BaseRepository {
    constructor(model) {
      this.model = model;
    }
  
    async create(data) {
      return await this.model.create(data);
    }
  
    async findById(id, populate = '') {
      return await this.model.findById(id).populate(populate);
    }
  
    async findOne(filter = {}, populate = '') {
      return await this.model.findOne(filter).populate(populate);
    }
  
    async find(filter = {}, options = {}) {
      const { sort = {}, populate = '', select = '', limit = 0, skip = 0 } = options;
      return await this.model
        .find(filter)
        .sort(sort)
        .populate(populate)
        .select(select)
        .limit(limit)
        .skip(skip)
        .lean();
    }
  
    async findAll(filter = {}, options = {}) {
      const { sort = {}, populate = '', limit = 0, skip = 0 } = options;
      return await this.model
        .find(filter)
        .sort(sort)
        .populate(populate)
        .limit(limit)
        .skip(skip)
        .lean();
    }
  
    async updateById(id, data) {
      return await this.model.findByIdAndUpdate(
        id,
        data,
        { new: true, runValidators: true }
      );
    }
  
    async updateOne(filter, data) {
      return await this.model.findOneAndUpdate(
        filter,
        data,
        { new: true, runValidators: true }
      );
    }
  
    async updateMany(filter, data) {
      return await this.model.updateMany(filter, data);
    }
  
    async deleteById(id) {
      return await this.model.findByIdAndDelete(id);
    }
  
    async deleteMany(filter = {}) {
      return await this.model.deleteMany(filter);
    }
  
    async count(filter = {}) {
      return await this.model.countDocuments(filter);
    }
  }
  
  module.exports = BaseRepository;

File: repositories\question.js
----------------------------------------
const BaseRepository = require('./baseRepository');
const Question = require('../models/question');

class QuestionRepository extends BaseRepository {
  constructor() {
    super(Question);
  }

  async findBySurveyId(surveyId) {
    return await this.model
      .find({ surveyId })
      .sort('order');
  }

  async getMaxOrder(surveyId) {
    const result = await this.model
      .findOne({ surveyId })
      .sort('-order')
      .select('order');
    return result ? result.order : 0;
  }

  async reorderQuestions(surveyId, questionOrder) {
    const bulkOps = questionOrder.map((questionId, index) => ({
      updateOne: {
        filter: { _id: questionId, surveyId },
        update: { $set: { order: index } }
      }
    }));

    return await this.model.bulkWrite(bulkOps);
  }
}

module.exports = QuestionRepository;

File: repositories\survey.js
----------------------------------------
// repositories/survey.js
const BaseRepository = require('./baseRepository');
const Survey = require('../models/survey');

class SurveyRepository extends BaseRepository {
  constructor() {
    super(Survey);
  }

  async findByIdWithFullDetails(id) {
    try {
      const survey = await this.model.findById(id);
      if (!survey) {
        return null;
      }

      const populatedSurvey = await this.model
        .findById(id)
        .populate({
          path: 'questions',
          select: 'questionText responseType isMandatory order responseValues',
          options: { sort: { order: 1 } }
        })
        .populate({
          path: 'createdBy',
          select: 'username email'
        })
        .lean();

      return populatedSurvey;
    } catch (error) {
      console.error('Error in findByIdWithFullDetails:', error);
      throw error;
    }
  }

  async findAllWithQuestions(filter = {}) {
    const surveys = await this.model
      .find(filter)
      .populate({
        path: 'questions',
        select: 'questionText responseType isMandatory order responseValues',
        options: { sort: { order: 1 } }
      })
      .lean();

    return surveys;
  }

  async updateById(id, data) {
    return await this.model
      .findByIdAndUpdate(
        id,
        data,
        { new: true, runValidators: true }
      )
      .lean();
  }

  async create(data) {
    const survey = await this.model.create(data);
    return survey.toObject();
  }
}

module.exports = SurveyRepository;

File: repositories\surveyProgress.js
----------------------------------------
const BaseRepository = require('./baseRepository');
const SurveyProgress = require('../models/surveyProgress');
const mongoose = require('mongoose');

class SurveyProgressRepository extends BaseRepository {
  constructor() {
    super(SurveyProgress);
  }

  async findBySurveyAndRespondent(surveyId, respondentId) {
    return await this.model
      .findOne({ surveyId, respondentId })
      .populate('answeredQuestions');
  }

  async findBySurveyWithRespondents(surveyId) {
    return await this.model
      .find({ surveyId })
      .populate('respondentId', 'username email')
      .sort('-updatedAt');
  }

  async findByRespondent(respondentId) {
    return await this.model
      .find({ respondentId })
      .populate('surveyId', 'title')
      .sort('-updatedAt');
  }

  async updateProgress(surveyId, respondentId, questionId) {
    const progress = await this.findBySurveyAndRespondent(surveyId, respondentId);
    
    if (!progress) {
      return null;
    }

    if (!progress.answeredQuestions.includes(questionId)) {
      progress.answeredQuestions.push(questionId);
    }

    if (progress.status === 'NOT_STARTED') {
      progress.status = 'IN_PROGRESS';
    }
    //to check if all the questions have been answered in the survey
    if(progress.answeredQuestions.length === survey.questions.length) {
      progress.status = 'COMPLETED';
      progress.completedAt = new Date();  
    }
//to compute the current progress of the survey
    progress.progress = (progress.answeredQuestions.length / survey.questions.length) * 100;
    return await progress.save();
  }

  async markAsCompleted(surveyId, respondentId) {
    return await this.model.findOneAndUpdate(
      { surveyId, respondentId },
      { 
        status: 'COMPLETED',
        completedAt: new Date(),
        modifiedBy: respondentId
      },
      { new: true }
    );
  }

  async getCompletionStats(surveyId) {
    const stats = await this.model.aggregate([
      { $match: { surveyId: mongoose.Types.ObjectId(surveyId) } },
      { 
        $group: {
          _id: '$status',
          count: { $sum: 1 },
          avgProgress: { $avg: '$progress' }
        }
      }
    ]);

    return stats.reduce((acc, stat) => {
      acc[stat._id.toLowerCase()] = {
        count: stat.count,
        avgProgress: Math.round(stat.avgProgress)
      };
      return acc;
    }, {});
  }

  async getSurveyParticipants(surveyId, filters = {}) {

    
    const query = { surveyId };

    if (filters.status) {
      query.status = filters.status;  
    }

    if (filters.minProgress) {
      query.progress = { $gte: Number(filters.minProgress) };
    }

    if (filters.startDate && filters.endDate) {
      query.startedAt = {
        $gte: new Date(filters.startDate),
        $lte: new Date(filters.endDate)
      };
    }
    
    return await this.model
      .find(query)
      .populate('respondentId', 'username email')
      .populate('surveyId', 'title')
      .sort('-updatedAt');
  }

  async getRespondentProgress(respondentId) {

    return await this.model
      .find(respondentId)
      .populate('surveyId', 'title description')
      .sort('-updatedAt');
  }

  async deleteAllProgressForSurvey(surveyId) {
    return await this.model.deleteMany({ surveyId });
  }
}

module.exports = SurveyProgressRepository;

File: repositories\user.js
----------------------------------------
const BaseRepository = require('./baseRepository');
const User = require('../models/user');

class UserRepository extends BaseRepository {
  constructor() {
    super(User);
  }

  async findByUsername(username) {
    return await this.model.findOne({ username }).select('+password');
  }

  async findByEmail(email) {
    return await this.model.findOne({ email }).select('+password');
  }
}

module.exports = UserRepository


File: routes\answer.js
----------------------------------------
// routes/answer.js
const express = require('express');
const router = express.Router();
const { answerController } = require('../bootstrap');
const auth = require('../middleware/auth');
const { validateAnswer } = require('../middleware/validation');

router.use(auth); 
router.post(
  '/questions/:questionId',
  validateAnswer,
  answerController.submitAnswer
);

router.get(
  '/surveys/:surveyId',
  answerController.getAnswersBySurvey
);

router.get(
  '/surveys/:surveyId/my-answers',
  answerController.getMyAnswers
);

router.get(
  '/questions/:questionId',
  answerController.getAnswersByQuestion
);

router.get(
  '/surveys/:surveyId/stats',
  answerController.getSurveyStats
);

router.delete(
  '/:answerId',
  answerController.deleteAnswer
);

module.exports = router;

File: routes\question.js
----------------------------------------
const express = require('express');
const router = express.Router();
const { questionController } = require('../bootstrap');
const auth = require('../middleware/auth');
const { 
  validateQuestion, 
  validateQuestionUpdate 
} = require('../middleware/validation');
const checkOwnership = require('../middleware/checkOwnership');

router.use(auth);

router.route('/')
  .post(validateQuestion, questionController.createQuestion);

router.route('/:id')
  .get(questionController.getById)
  .put(checkOwnership('Question'), validateQuestionUpdate, questionController.updateQuestion)
  .delete(checkOwnership('Question'), questionController.delete);

router.put('/:id/move', 
  checkOwnership('Question'), 
  questionController.moveQuestion
);

module.exports = router;

File: routes\survey.js
----------------------------------------
const express = require('express');
const router = express.Router();
const { surveyController } = require('../bootstrap');
const auth = require('../middleware/auth');
const { 
  validateSurvey, 
  validateSurveyUpdate, 
  validateReorderQuestions 
} = require('../middleware/validation');
const checkOwnership = require('../middleware/checkOwnership');

router.use(auth);

router.route('/')
  .get(surveyController.getAllSurveys)
  .post(validateSurvey, surveyController.createSurvey);

router.route('/:id')
  .get(surveyController.getById)
  .put(checkOwnership('Survey'), validateSurveyUpdate, surveyController.update)
  .delete(checkOwnership('Survey'), surveyController.delete);

router.get('/:id',surveyController.getById)
router.post('/:id/duplicate', surveyController.duplicateSurvey);
router.put('/:id/archive', checkOwnership('Survey'), surveyController.archiveSurvey);
router.put('/:id/unarchive', checkOwnership('Survey'), surveyController.unarchiveSurvey);
router.put('/:id/reorder-questions', 
  checkOwnership('Survey'), 
  validateReorderQuestions, 
  surveyController.reorderQuestions
);

module.exports = router;

File: routes\surveyProgress.js
----------------------------------------
// routes/surveyProgress.js
const express = require('express');
const router = express.Router();
const { surveyProgressController } = require('../bootstrap');
const auth = require('../middleware/auth');

router.use(auth);

router.post(
  '/surveys/:surveyId/initialize',
  surveyProgressController.initializeProgress
);

router.put(
  '/surveys/:surveyId/questions/:questionId',
  surveyProgressController.updateProgress
);

router.get(
  '/surveys/:surveyId',
  surveyProgressController.getProgress
);

router.get(
  '/surveys/:surveyId/participants',
  surveyProgressController.getParticipants
);

router.get(
  '/surveys/:surveyId/stats',
  surveyProgressController.getCompletionStats
);

router.get(
  '/my-progress',
  surveyProgressController.getMyProgress
);

module.exports = router;

File: routes\user.js
----------------------------------------
const express = require('express');
const router = express.Router();
const { userController } = require('../bootstrap');
const auth = require('../middleware/auth');
const { 
  validateUserRegister, 
  validateUserLogin 
} = require('../middleware/validation');

router.post('/register', validateUserRegister, userController.registerUser);
router.post('/login', validateUserLogin, userController.loginUser);
router.get('/current', auth, userController.getCurrentUser);

module.exports = router;

File: script.js
----------------------------------------
const fs = require('fs');
const path = require('path');

var num = 0;

// Directory to start scanning
const startDir = './'; // Change this to your starting directory if needed
const outputFilePath = 'output.txt';

// Function to get all .js files from a directory recursively
function getAllJsFiles(dir, fileList = []) {
  const files = fs.readdirSync(dir);

  files.forEach((file) => {
    const filePath = path.join(dir, file);
    const stat = fs.statSync(filePath);

    if (stat.isDirectory() && file !== 'node_modules') {
      getAllJsFiles(filePath, fileList);
    } else if (path.extname(file) === '.js') {
      fileList.push(filePath);
    }
  });

  return fileList;
}

// Function to write all .js file names, paths, and content to a .txt file
function writeJsFilesToTxt(jsFiles, outputFile) {
  const writeStream = fs.createWriteStream(outputFile);

  jsFiles.forEach((filePath) => {
    const content = fs.readFileSync(filePath, 'utf8');
    writeStream.write(`File: ${filePath}\n`);
    writeStream.write('----------------------------------------\n');
    writeStream.write(`${content}\n\n`);
    num  = num +1;
  });


  writeStream.end();
}

// Main process
try {
  const jsFiles = getAllJsFiles(startDir);
  writeJsFilesToTxt(jsFiles, outputFilePath);
  console.log(`All JavaScript files have been written to ${outputFilePath}`);
  console.log(num);
} catch (err) {
  console.error('Error:', err);
}

File: service\answer.js
----------------------------------------
const BaseService = require('./baseService');
const CustomError = require('../utils/customError');

class AnswerService extends BaseService {
  constructor(answerRepository, questionService, surveyService, surveyProgressService) {
    super(answerRepository);
    this.questionService = questionService;
    this.surveyService = surveyService;
    this.surveyProgressService = surveyProgressService; 
  }

  async createAnswer(data) {
    try {
      const question = await this.questionService.getQuestionById(data.questionId);
      if (!question) {
        throw new CustomError('Question not found', 404);
      }

      await this.validateAnswer(question, data.answerValue);

      const existingAnswer = await this.repository.findOne({
        questionId: data.questionId,
        respondentId: data.respondentId
      });

      if (existingAnswer) {
        throw new CustomError('Answer already exists for this question', 400);
      }

      const answer = await this.create({
        ...data,
        surveyId: question.surveyId,
        isValid: true,
        validatedAt: new Date()
      });

      await this.updateSurveyProgress(
        question.surveyId,
        data.respondentId,
        question._id
      );

      return answer;
    } catch (error) {
      if (error instanceof CustomError) throw error;
      throw new CustomError('Error creating answer', 500);
    }
  }

  async updateSurveyProgress(surveyId, respondentId, questionId) {
    try {
      let progress = await this.surveyProgressService.findBySurveyAndRespondent(
        surveyId,
        respondentId
      );

      if (!progress) {
        progress = await this.surveyProgressService.initializeProgress(
          surveyId,
          respondentId
        );
      }

      await this.surveyProgressService.updateProgress(
        surveyId,
        respondentId,
        questionId
      );

    } catch (error) {
      throw new CustomError('Error updating survey progress', 500);
    }
  }

  async validateAnswer(question, answerValue) {
    switch (question.responseType) {
      case 'text':
        if (typeof answerValue !== 'string') {
          throw new CustomError('Answer must be a text value', 400);
        }
        break;

      case 'multiple-choice':
        if (!Array.isArray(answerValue)) {
          throw new CustomError('Answer must be an array for multiple-choice questions', 400);
        }
        if (!question.allowMultiple && answerValue.length > 1) {
          throw new CustomError('Multiple selections not allowed for this question', 400);
        }
        const validValues = question.responseValues.map(rv => rv.value);
        const invalidValues = answerValue.filter(v => !validValues.includes(v));
        if (invalidValues.length > 0) {
          throw new CustomError(`Invalid options selected: ${invalidValues.join(', ')}`, 400);
        }
        break;

      case 'single-choice':
        if (Array.isArray(answerValue)) {
          throw new CustomError('Single choice question cannot have multiple answers', 400);
        }
        if (!question.responseValues.some(rv => rv.value === answerValue)) {
          throw new CustomError('Invalid option selected', 400);
        }
        break;

      case 'rating':
        const rating = Number(answerValue);
        if (isNaN(rating) || rating < 1 || rating > 5) {
          throw new CustomError('Rating must be a number between 1 and 5', 400);
        }
        break;

      case 'boolean':
        if (typeof answerValue !== 'boolean') {
          throw new CustomError('Answer must be true or false', 400);
        }
        break;

      default:
        throw new CustomError('Invalid question type', 400);
    }

    return true;
  }

  async getAnswersBySurvey(surveyId, userId) {
    try {
      const survey = await this.surveyService.getSurveyById(surveyId);
      if (!survey) {
        throw new CustomError('Survey not found', 404);
      }

      if (survey.createdBy.toString() !== userId && userId.role !== 'admin') {
        throw new CustomError('Not authorized to view all answers', 403);
      }

      return await this.repository.findBySurveyAndRespondent(surveyId);
    } catch (error) {
      if (error instanceof CustomError) throw error;
      throw new CustomError('Error retrieving answers', 500);
    }
  }

  async getAnswersByQuestion(questionId) {
    try {
      const question = await this.questionService.getQuestionById(questionId);
      if (!question) {
        throw new CustomError('Question not found', 404);
      }

      return await this.repository.findQuestionAnswers(questionId);
    } catch (error) {
      if (error instanceof CustomError) throw error;
      throw new CustomError('Error retrieving answers', 500);
    }
  }

  async getRespondentAnswers(surveyId, respondentId) {
    try {
      const survey = await this.surveyService.getSurveyById(surveyId);
      if (!survey) {
        throw new CustomError('Survey not found', 404);
      }

      return await this.repository.findBySurveyAndRespondent(surveyId, respondentId);
    } catch (error) {
      if (error instanceof CustomError) throw error;
      throw new CustomError('Error retrieving answers', 500);
    }
  }

  async getSurveyStats(surveyId) {
    try {
      const survey = await this.surveyService.getSurveyById(surveyId);
      if (!survey) {
        throw new CustomError('Survey not found', 404);
      }

      const answers = await this.repository.findAll({ surveyId });
      const questionStats = {};

      answers.forEach(answer => {
        if (!questionStats[answer.questionId]) {
          questionStats[answer.questionId] = {
            totalAnswers: 0,
            answerDistribution: {}
          };
        }

        questionStats[answer.questionId].totalAnswers++;

        const value = Array.isArray(answer.answerValue) 
          ? answer.answerValue.join(', ') 
          : answer.answerValue.toString();

        questionStats[answer.questionId].answerDistribution[value] = 
          (questionStats[answer.questionId].answerDistribution[value] || 0) + 1;
      });

      return questionStats;
    } catch (error) {
      if (error instanceof CustomError) throw error;
      throw new CustomError('Error getting survey statistics', 500);
    }
  }

  async deleteAnswer(answerId, userId, userRole) {
    try {
      const answer = await this.findById(answerId);
      if (!answer) {
        throw new CustomError('Answer not found', 404);
      }

      // Only answer creator or admin can delete
      if (answer.respondentId.toString() !== userId && userRole !== 'admin') {
        throw new CustomError('Not authorized to delete this answer', 403);
      }

      return await this.deleteById(answerId);
    } catch (error) {
      if (error instanceof CustomError) throw error;
      throw new CustomError('Error deleting answer', 500);
    }
  }
}

module.exports = AnswerService;

File: service\baseService.js
----------------------------------------
// service/baseService.js
const CustomError = require('../utils/customError');
const mongoose = require('mongoose');

class BaseService {
  constructor(repository) {
    this.repository = repository;
  }

  async create(data) {
    try {
      const item = await this.repository.create(data);
      if (!item) {
        throw new CustomError('Failed to create resource', 400);
      }
      return item;
    } catch (error) {
      if (error.code === 11000) {
        throw new CustomError('Resource with this identifier already exists', 400);
      }
      if (error instanceof CustomError) {
        throw error;
      }
      throw new CustomError(`Error creating resource: ${error.message}`, 500);
    }
  }

  async findById(id, populate = '') {
    try {
      if (!mongoose.Types.ObjectId.isValid(id)) {
        throw new CustomError('Invalid ID format', 400);
      }

      const item = await this.repository.findById(id, populate);
      if (!item) {
        throw new CustomError('Resource not found', 404);
      }
      return item;
    } catch (error) {
      if (error instanceof CustomError) {
        throw error;
      }
      throw new CustomError(`Error retrieving resource: ${error.message}`, 500);
    }
  }

  async findAll(filter = {}, options = {}) {
    try {
      const items = await this.repository.findAll(filter, options);
      return items;
    } catch (error) {
      if (error instanceof CustomError) {
        throw error;
      }
      throw new CustomError(`Error retrieving resources: ${error.message}`, 500);
    }
  }

  async updateById(id, data) {
    try {
      if (!mongoose.Types.ObjectId.isValid(id)) {
        throw new CustomError('Invalid ID format', 400);
      }

      const item = await this.repository.updateById(id, data);
      if (!item) {
        throw new CustomError('Resource not found', 404);
      }
      return item;
    } catch (error) {
      if (error.code === 11000) {
        throw new CustomError('Resource with this identifier already exists', 400);
      }
      if (error instanceof CustomError) {
        throw error;
      }
      throw new CustomError(`Error updating resource: ${error.message}`, 500);
    }
  }

  async deleteById(id) {
    try {
      if (!mongoose.Types.ObjectId.isValid(id)) {
        throw new CustomError('Invalid ID format', 400);
      }

      const item = await this.repository.deleteById(id);
      if (!item) {
        throw new CustomError('Resource not found', 404);
      }
      return item;
    } catch (error) {
      if (error instanceof CustomError) {
        throw error;
      }
      throw new CustomError(`Error deleting resource: ${error.message}`, 500);
    }
  }

  async findOne(filter = {}, populate = '') {
    try {
      const item = await this.repository.findOne(filter, populate);
      if (!item) {
        throw new CustomError('Resource not found', 404);
      }
      return item;
    } catch (error) {
      if (error instanceof CustomError) {
        throw error;
      }
      throw new CustomError(`Error finding resource: ${error.message}`, 500);
    }
  }

  async count(filter = {}) {
    try {
      return await this.repository.count(filter);
    } catch (error) {
      throw new CustomError(`Error counting resources: ${error.message}`, 500);
    }
  }

  async exists(filter = {}) {
    try {
      const count = await this.repository.count(filter);
      return count > 0;
    } catch (error) {
      throw new CustomError(`Error checking resource existence: ${error.message}`, 500);
    }
  }

  async findOneOrCreate(filter = {}, data = {}) {
    try {
      let item = await this.repository.findOne(filter);
      if (!item) {
        item = await this.repository.create({ ...data, ...filter });
      }
      return item;
    } catch (error) {
      if (error instanceof CustomError) {
        throw error;
      }
      throw new CustomError(`Error finding or creating resource: ${error.message}`, 500);
    }
  }

  async updateOne(filter = {}, data) {
    try {
      const item = await this.repository.updateOne(filter, data);
      if (!item) {
        throw new CustomError('Resource not found', 404);
      }
      return item;
    } catch (error) {
      if (error instanceof CustomError) {
        throw error;
      }
      throw new CustomError(`Error updating resource: ${error.message}`, 500);
    }
  }

  async deleteOne(filter = {}) {
    try {
      const item = await this.repository.deleteOne(filter);
      if (!item) {
        throw new CustomError('Resource not found', 404);
      }
      return item;
    } catch (error) {
      if (error instanceof CustomError) {
        throw error;
      }
      throw new CustomError(`Error deleting resource: ${error.message}`, 500);
    }
  }
}

module.exports = BaseService;

File: service\question.js
----------------------------------------
const BaseService = require('./baseService');
const CustomError = require('../utils/customError');
const mongoose = require('mongoose');

class QuestionService extends BaseService {
  constructor(questionRepository, surveyService) {
    super(questionRepository);
    this.surveyService = surveyService;
  }

  async createQuestion(data) {
    try {

      if (!data.surveyId) {
        throw new CustomError('Survey ID is required', 400);
      }      

      const survey = await this.surveyService.getSurveyById(data.surveyId);
      if (!survey) {
        throw new CustomError('Survey not found', 404);
      }

      const maxOrder = await this.getMaxQuestionOrder(data.surveyId);
      
      const questionData = {
        questionText: data.questionText,
        responseType: data.responseType,
        isMandatory: data.isMandatory,
        surveyId: data.surveyId,
        order: maxOrder + 1,
        createdBy: data.createdBy
      };

      if (['multiple-choice', 'single-choice'].includes(data.responseType)) {
        questionData.responseValues = data.responseValues;
        questionData.allowMultiple = data.allowMultiple || false;
      }


      const question = await this.repository.create(questionData);

      if (question._id) {
        await this.surveyService.addQuestionToSurvey(data.surveyId, question._id);
      }

      return question;
    } catch (error) {
      if (error instanceof CustomError) throw error;
      throw new CustomError(`Error creating question: ${error.message}`, 500);
    }
  }

  async getMaxQuestionOrder(surveyId) {
    try {
      const questions = await this.repository.find(
        { surveyId },
        { 
          sort: { order: -1 },
          limit: 1
        }
      );
      return questions.length > 0 ? questions[0].order : 0;
    } catch (error) {
      console.error('Error getting max order:', error);
      return 0;
    }
  }

  async getQuestionById(id) {
    try {
      if (!mongoose.Types.ObjectId.isValid(id)) {
        throw new CustomError('Invalid question ID', 400);
      }

      const question = await this.repository.findById(id);
      if (!question) {
        throw new CustomError('Question not found', 404);
      }

      return question;
    } catch (error) {
      if (error instanceof CustomError) throw error;
      throw new CustomError('Error retrieving question', 500);
    }
  }

  async getMaxQuestionOrder(surveyId) {
    try {
      const questions = await this.repository.find(
        { surveyId },
        { 
          sort: { order: -1 },
          limit: 1,
          select: 'order'
        }
      );
      return questions.length > 0 ? questions[0].order : 0;
    } catch (error) {
      throw new CustomError('Error getting max question order', 500);
    }
  }

  async getQuestionsBySurvey(surveyId) {
    try {
      if (!mongoose.Types.ObjectId.isValid(surveyId)) {
        throw new CustomError('Invalid survey ID', 400);
      }

      return await this.repository.find(
        { surveyId },
        { 
          sort: { order: 1 },
          select: '-__v'
        }
      );
    } catch (error) {
      throw new CustomError('Error getting survey questions', 500);
    }
  }

  async updateQuestion(id, data) {
    try {
      if (!mongoose.Types.ObjectId.isValid(id)) {
        throw new CustomError('Invalid question ID', 400);
      }

      const question = await this.getQuestionById(id);

      const updateData = {
        ...data,
        surveyId: undefined,
        order: undefined,
        responseType: undefined 
      };

      if (updateData.responseValues) {
        await this.validateResponseValues(question.responseType, updateData.responseValues);
      }

      const updatedQuestion = await this.repository.updateById(id, updateData);
      if (!updatedQuestion) {
        throw new CustomError('Question not found', 404);
      }

      return updatedQuestion;
    } catch (error) {
      if (error instanceof CustomError) throw error;
      throw new CustomError('Error updating question', 500);
    }
  }

  async deleteQuestion(id) {
    try {
      if (!mongoose.Types.ObjectId.isValid(id)) {
        throw new CustomError('Invalid question ID', 400);
      }

      const question = await this.getQuestionById(id);
      
      await this.repository.deleteById(id);

      const remainingQuestions = await this.getQuestionsBySurvey(question.surveyId);
      await this.reorderSurveyQuestions(
        question.surveyId,
        remainingQuestions.map(q => q._id)
      );

      await this.surveyService.removeQuestionFromSurvey(question.surveyId, id);

      return { success: true, message: 'Question deleted successfully' };
    } catch (error) {
      if (error instanceof CustomError) throw error;
      throw new CustomError('Error deleting question', 500);
    }
  }

  async reorderSurveyQuestions(surveyId, questionOrder) {
    try {
      if (!mongoose.Types.ObjectId.isValid(surveyId)) {
        throw new CustomError('Invalid survey ID', 400);
      }

      const questions = await this.getQuestionsBySurvey(surveyId);
      const existingIds = new Set(questions.map(q => q._id.toString()));
      
      const validOrder = questionOrder.every(id => existingIds.has(id.toString()));
      if (!validOrder) {
        throw new CustomError('Invalid question order provided', 400);
      }

      const bulkOps = questionOrder.map((questionId, index) => ({
        updateOne: {
          filter: { _id: questionId, surveyId },
          update: { $set: { order: index } }
        }
      }));

      await this.repository.bulkWrite(bulkOps);
      return await this.getQuestionsBySurvey(surveyId);
    } catch (error) {
      if (error instanceof CustomError) throw error;
      throw new CustomError('Error reordering questions', 500);
    }
  }

  async moveQuestion(surveyId, questionId, direction) {
    try {
      if (!mongoose.Types.ObjectId.isValid(surveyId) || 
          !mongoose.Types.ObjectId.isValid(questionId)) {
        throw new CustomError('Invalid survey or question ID', 400);
      }

      const question = await this.getQuestionById(questionId);
      
      const nearQuestion = await this.repository.findOne({
        surveyId,
        order: direction === 'up' ? question.order - 1 : question.order + 1
      });

      if (!nearQuestion) {
        throw new CustomError(`Cannot move question ${direction}`, 400);
      }

      const tempOrder = question.order;
      await this.repository.updateById(question._id, { order: nearQuestion.order });
      await this.repository.updateById(nearQuestion._id, { order: tempOrder });

      return await this.getQuestionsBySurvey(surveyId);
    } catch (error) {
      if (error instanceof CustomError) throw error;
      throw new CustomError('Error moving question', 500);
    }
  }

  async duplicateQuestion(questionId, newSurveyId, userId) {
    try {
      if (!mongoose.Types.ObjectId.isValid(questionId) || 
          !mongoose.Types.ObjectId.isValid(newSurveyId)) {
        throw new CustomError('Invalid question or survey ID', 400);
      }

      const originalQuestion = await this.getQuestionById(questionId);
      const maxOrder = await this.getMaxQuestionOrder(newSurveyId);

      const questionData = {
        surveyId: newSurveyId,
        questionText: originalQuestion.questionText,
        responseType: originalQuestion.responseType,
        responseValues: originalQuestion.responseValues,
        allowMultiple: originalQuestion.allowMultiple,
        isMandatory: originalQuestion.isMandatory,
        order: maxOrder + 1,
        createdBy: userId
      };

      return await this.repository.create(questionData);
    } catch (error) {
      if (error instanceof CustomError) throw error;
      throw new CustomError('Error duplicating question', 500);
    }
  }

  async validateQuestionData(data) {
    const validTypes = ['text', 'multiple-choice', 'single-choice', 'rating', 'boolean'];
    if (!validTypes.includes(data.responseType)) {
      throw new CustomError('Invalid question type', 400);
    }

    await this.validateResponseValues(data.responseType, data.responseValues);

    if (data.responseType !== 'multiple-choice' && data.allowMultiple) {
      throw new CustomError('allowMultiple can only be true for multiple-choice questions', 400);
    }

    return true;
  }

  async validateResponseValues(responseType, responseValues) {
    switch (responseType) {
      case 'multiple-choice':
      case 'single-choice':
        if (!Array.isArray(responseValues) || responseValues.length < 2) {
          throw new CustomError('Choice questions must have at least 2 options', 400);
        }
        break;

      case 'rating':
        if (responseValues !== undefined) {
          throw new CustomError('Rating questions cannot have response values', 400);
        }
        break;

      case 'boolean':
        if (responseValues !== undefined) {
          throw new CustomError('Boolean questions cannot have response values', 400);
        }
        break;

      case 'text':
        if (responseValues !== undefined) {
          throw new CustomError('Text questions cannot have response values', 400);
        }
        break;

      default:
        throw new CustomError('Invalid question type', 400);
    }

    return true;
  }

  async validateQuestionResponse(questionId, answerValue) {
    try {
      const question = await this.getQuestionById(questionId);
      
      switch (question.responseType) {
        case 'text':
          if (typeof answerValue !== 'string') {
            throw new CustomError('Answer must be a text value', 400);
          }
          break;

        case 'multiple-choice':
          if (!Array.isArray(answerValue)) {
            throw new CustomError('Answer must be an array for multiple-choice questions', 400);
          }
          if (!question.allowMultiple && answerValue.length > 1) {
            throw new CustomError('Multiple selections not allowed for this question', 400);
          }
          const validValues = question.responseValues.map(rv => rv.value);
          const invalidValues = answerValue.filter(v => !validValues.includes(v));
          if (invalidValues.length > 0) {
            throw new CustomError(`Invalid options selected: ${invalidValues.join(', ')}`, 400);
          }
          break;

        case 'single-choice':
          if (Array.isArray(answerValue)) {
            throw new CustomError('Single choice question cannot have multiple answers', 400);
          }
          if (!question.responseValues.some(rv => rv.value === answerValue)) {
            throw new CustomError('Invalid option selected', 400);
          }
          break;

        case 'rating':
          const rating = Number(answerValue);
          if (isNaN(rating) || rating < 1 || rating > 5) {
            throw new CustomError('Rating must be a number between 1 and 5', 400);
          }
          break;

        case 'boolean':
          if (typeof answerValue !== 'boolean') {
            throw new CustomError('Answer must be true or false', 400);
          }
          break;

        default:
          throw new CustomError('Invalid question type', 400);
      }

      return true;
    } catch (error) {
      if (error instanceof CustomError) throw error;
      throw new CustomError('Error validating question response', 500);
    }
  }
}

module.exports = QuestionService;

File: service\survey.js
----------------------------------------
const BaseService = require('./baseService');
const CustomError = require('../utils/customError');
const mongoose = require('mongoose');

class SurveyService extends BaseService {
  constructor(surveyRepository) {
    super(surveyRepository);
    this._questionService = null;
  }

  setQuestionService(questionService) {
    this._questionService = questionService;
  }

  async createSurvey(data) {
    try {
      if (!data.title) {
        throw new CustomError('Title is required', 400); 
      }
  
      const existingSurvey = await this.repository.findOne({ 
        title: data.title 
      });
  
      if (existingSurvey) {
        throw new CustomError('Survey with this title already exists', 400);
      }
  
      const survey = await this.create({
        ...data,
        questions: [],
        questionOrder: [],
        isArchived: false,
        archivedAt: null
      });
  
      return await this.getSurveyById(survey.id);
    } catch (error) {
      if (error instanceof CustomError) throw error;
      throw new CustomError('Error creating survey', 500); // Changed status to 500 for internal errors
    }
  }
  

  async getSurveyById(id) {
    try {
        console.log('@!@!@!@! ')
      

      const survey = await this.repository.findByIdWithFullDetails(id);
      console.log('@!@!@!@! Found survey:', survey); 
      if (!survey) {
        throw new CustomError('Survey not found', 404);
      }
      return survey;
    } catch (error) {
      if (error instanceof CustomError) throw error;
      throw new CustomError('Error retrieving survey', 400);
    }
  }

  async getAllSurveys(filter = {}) {
    try {
      if (filter.isArchived !== undefined) {
        filter.isArchived = filter.isArchived === 'true';
      }
  
      const surveys = await this.repository.findAllWithQuestions(filter);
      return surveys.map(survey => ({
        id: survey.id || survey._id,
        title: survey.title,
        description: survey.description,
        isTemplate: survey.isTemplate,
        isArchived: survey.isArchived,
        questions: Array.isArray(survey.questions) ? survey.questions.map(q => ({
          id: q.id || q._id,
          questionText: q.questionText,
          responseType: q.responseType,
          isMandatory: q.isMandatory,
          order: q.order,
          responseValues: q.responseValues
        })) : [],
        questionCount: Array.isArray(survey.questions) ? survey.questions.length : 0,
        isComplete: Array.isArray(survey.questions) && survey.questions.length > 0,
        createdBy: survey.createdBy,
        createdAt: survey.createdAt,
        updatedAt: survey.updatedAt
      }));
    } catch (error) {
      throw new CustomError('Error retrieving surveys', 400);
    }
  }
  async updateSurvey(id, data, userId) {
    try {
        console.log(`@!@!@!@! Update survey process started for survey ID: ${id}`);

        if (!mongoose.Types.ObjectId.isValid(id)) {
            console.log(`@!@!@!@! Invalid survey ID provided: ${id}`);
            throw new CustomError('Invalid survey ID', 400);
        }

        // Fetch the survey before updating
        const survey = await this.getSurveyById(id);
        console.log(`@!@!@!@! Found survey before update: ${JSON.stringify(survey)}`);

        // Check for duplicate title if a new title is provided
        if (data.title && data.title !== survey.title) {
            console.log(`@!@!@!@! Checking for duplicate title: ${data.title}`);
            const existingSurvey = await this.repository.findOne({ 
                title: data.title,
                _id: { $ne: id }
            });
            if (existingSurvey) {
                console.log(`@!@!@!@! Duplicate title found for title: ${data.title}`);
                throw new CustomError('Survey with this title already exists', 400);
            }
        }

        // Update survey with new data
        console.log(`@!@!@!@! Updating survey with data: ${JSON.stringify(data)}`);
        const updatedSurvey = await this.repository.updateById(id, {
            ...data,
            modifiedBy: userId,
            modifiedAt: new Date()
        });
        console.log(`@!@!@!@! Survey updated successfully. Updated survey data: ${JSON.stringify(updatedSurvey)}`);
        // Fetch and return the updated survey
        const result = await this.getSurveyById(updatedSurvey._id);
        console.log(`@!@!@!@! Retrieved updated survey: ${JSON.stringify(result)}`);
        return result;
    } catch (error) {
        console.error(`@!@!@!@! Error in updateSurvey: ${error.message}`);
        if (error instanceof CustomError) throw error;
        throw new CustomError('Error updating survey', 500);
    }
}


  async addQuestionToSurvey(surveyId, questionId) {
    try {
        console.log('@!@!@!@! This function is called')
      if (!mongoose.Types.ObjectId.isValid(surveyId) || 
          !mongoose.Types.ObjectId.isValid(questionId)) {
        throw new CustomError('Invalid survey or question ID', 400);
      }

      const survey = await this.repository.findById(surveyId);
      if (!survey) {
        throw new CustomError('Survey not found', 404);
      }

      if (!survey.questions) survey.questions = [];
      if (!survey.questionOrder) survey.questionOrder = [];
      console.log('@!@!@!@! in survey service',survey.questions)
      if (!survey.questions.includes(questionId)) {
        survey.questions.push(questionId);
        survey.questionOrder.push(questionId);
        
        await this.repository.updateById(surveyId, {
          questions: survey.questions,
          questionOrder: survey.questionOrder
        });
      }

      return await this.getSurveyById(surveyId);
    } catch (error) {
      if (error instanceof CustomError) throw error;
      throw new CustomError('Error adding question to survey', 500);
    }
  }

  async removeQuestionFromSurvey(surveyId, questionId) {
    try {
      if (!mongoose.Types.ObjectId.isValid(surveyId) || 
          !mongoose.Types.ObjectId.isValid(questionId)) {
        throw new CustomError('Invalid survey or question ID', 400);
      }

      const survey = await this.getSurveyById(surveyId);

      survey.questions = survey.questions.filter(
        id => id.toString() !== questionId.toString()
      );
      survey.questionOrder = survey.questionOrder.filter(
        id => id.toString() !== questionId.toString()
      );

      await this.repository.updateById(surveyId, {
        questions: survey.questions,
        questionOrder: survey.questionOrder
      });

      return await this.getSurveyById(surveyId);
    } catch (error) {
      if (error instanceof CustomError) throw error;
      throw new CustomError('Error removing question from survey', 500);
    }
  }

  async archiveSurvey(id, userId) {
    try {
      const survey = await this.getSurveyById(id);

      if (survey.isArchived) {
        throw new CustomError('Survey is already archived', 400);
      }

      await this.repository.updateById(id, {
        isArchived: true,
        archivedAt: new Date(),
        modifiedBy: userId
      });

      return await this.getSurveyById(id);
    } catch (error) {
      if (error instanceof CustomError) throw error;
      throw new CustomError('Error archiving survey', 500);
    }
  }

  async unarchiveSurvey(id, userId) {
    try {
      const survey = await this.getSurveyById(id);

      if (!survey.isArchived) {
        throw new CustomError('Survey is not archived', 400);
      }

      await this.repository.updateById(id, {
        isArchived: false,
        archivedAt: null,
        modifiedBy: userId
      });

      return await this.getSurveyById(id);
    } catch (error) {
      if (error instanceof CustomError) throw error;
      throw new CustomError('Error unarchiving survey', 500);
    }
  }

  async duplicateSurvey(id, userId) {
    try {
      const originalSurvey = await this.getSurveyById(id);

      const newSurvey = await this.createSurvey({
        title: `${originalSurvey.title} (Copy)`,
        description: originalSurvey.description,
        isTemplate: originalSurvey.isTemplate,
        createdBy: userId
      });

      if (originalSurvey.questions && originalSurvey.questions.length > 0) {
        for (const question of originalSurvey.questions) {
          const newQuestion = await this._questionService.duplicateQuestion(
            question._id,
            newSurvey._id,
            userId
          );
          await this.addQuestionToSurvey(newSurvey._id, newQuestion._id);
        }
      }

      return await this.getSurveyById(newSurvey._id);
    } catch (error) {
      if (error instanceof CustomError) throw error;
      throw new CustomError('Error duplicating survey', 500);
    }
  }

  async reorderQuestions(surveyId, questionOrder) {
    try {
      const survey = await this.getSurveyById(surveyId);

      const currentQuestions = new Set(survey.questions.map(q => q.toString()));
      const validOrder = questionOrder.every(id => currentQuestions.has(id.toString()));
      
      if (!validOrder) {
        throw new CustomError('Invalid question order provided', 400);
      }

      await this.repository.updateById(surveyId, {
        questionOrder: questionOrder
      });

      if (this._questionService) {
        await this._questionService.reorderSurveyQuestions(surveyId, questionOrder);
      }

      return await this.getSurveyById(surveyId);
    } catch (error) {
      if (error instanceof CustomError) throw error;
      throw new CustomError('Error reordering questions', 500);
    }
  }

  async deleteSurvey(id, userId) {
    try {
      const survey = await this.getSurveyById(id);

      if (survey.questions && survey.questions.length > 0) {
        for (const questionId of survey.questions) {
          await this._questionService.deleteQuestion(questionId);
        }
      }

      await this.deleteById(id);
      return { success: true, message: 'Survey deleted successfully' };
    } catch (error) {
      if (error instanceof CustomError) throw error;
      throw new CustomError('Error deleting survey', 500);
    }
  }

  async validateSurveyAccess(surveyId, userId, requiredRole = null) {
    try {
      const survey = await this.getSurveyById(surveyId);
      
      if (survey.createdBy.toString() !== userId.toString() && 
          (requiredRole && requiredRole !== 'admin')) {
        throw new CustomError('Not authorized to access this survey', 403);
      }
      
      return survey;
    } catch (error) {
      if (error instanceof CustomError) throw error;
      throw new CustomError('Error validating survey access', 500);
    }
  }

  async getSurveyStats(surveyId) {
    try {
      const survey = await this.getSurveyById(surveyId);
      
      return {
        totalQuestions: survey.questions.length,
        questionTypes: survey.questions.reduce((acc, q) => {
          acc[q.responseType] = (acc[q.responseType] || 0) + 1;
          return acc;
        }, {}),
        mandatoryQuestions: survey.questions.filter(q => q.isMandatory).length,
        isComplete: survey.questions.length > 0,
        lastUpdated: survey.updatedAt,
        createdAt: survey.createdAt
      };
    } catch (error) {
      if (error instanceof CustomError) throw error;
      throw new CustomError('Error getting survey statistics', 500);
    }
  }
}

module.exports = SurveyService;

File: service\surveyProgress.js
----------------------------------------
const BaseService = require('./baseService');
const CustomError = require('../utils/customError');
const mongoose = require('mongoose');

class SurveyProgressService extends BaseService {
  constructor(surveyProgressRepository, surveyService, questionService) {
    super(surveyProgressRepository);
    this.surveyService = surveyService;
    this.questionService = questionService;
  }

  async findBySurveyAndRespondent(surveyId, respondentId) {
    try {
      return await this.repository.findOne({
        surveyId,
        respondentId
      });
    } catch (error) {
      throw new CustomError('Error in finding survey progress', 500);
    }
  }

  async initializeProgress(surveyId, respondentId) {
    try {

      const existingProgress = await this.findBySurveyAndRespondent(surveyId, respondentId);
      if (existingProgress) {
        return existingProgress;
      }

      const survey = await this.surveyService.getSurveyById(surveyId);
      if (!survey) {
        throw new CustomError('Survey is not found', 404);
      }

      const progress = await this.repository.create({
        surveyId,
        respondentId,
        status: 'NOT_STARTED',
        answeredQuestions: [],
        progress: 0,
        startedAt: null,
        completedAt: null,
        lastAnsweredAt: new Date()
      });

      return progress;
    } catch (error) {
      if (error instanceof CustomError) throw error;
      throw new CustomError('Error initializing survey progress', 500);
    }
  }

  async updateProgress(surveyId, respondentId, questionId) {
    try {

      let progress = await this.findBySurveyAndRespondent(surveyId, respondentId);
      if (!progress) {
        progress = await this.initializeProgress(surveyId, respondentId);
      }

      const survey = await this.surveyService.getSurveyById(surveyId);
      const totalQuestions = survey.questions.length;

      if (progress.status === 'NOT_STARTED') {
        progress.status = 'IN_PROGRESS';
        progress.startedAt = new Date();
      }

      const questionIdStr = questionId.toString();
      if (!progress.answeredQuestions.map(q => q.toString()).includes(questionIdStr)) {
        progress.answeredQuestions.push(questionId);
      }

      progress.progress = Math.round((progress.answeredQuestions.length / totalQuestions) * 100);

      if (progress.progress === 100) {
        progress.status = 'COMPLETED';
        progress.completedAt = new Date();
      }

      progress.lastAnsweredAt = new Date();

      const updatedProgress = await this.repository.updateById(progress.id, {
        status: progress.status,
        answeredQuestions: progress.answeredQuestions,
        progress: progress.progress,
        startedAt: progress.startedAt,
        completedAt: progress.completedAt,
        lastAnsweredAt: progress.lastAnsweredAt
      });

      return updatedProgress;
    } catch (error) {
            if (error instanceof CustomError) throw error;
      throw new CustomError('Error updating survey progress', 500);
    }
  }

  async getProgress(surveyId, respondentId) {
    try {
      const survey = await this.surveyService.getSurveyById(surveyId);
      if (!survey) {
        throw new CustomError('Survey not found', 404);
      }

      const progress = await this.findBySurveyAndRespondent(surveyId, respondentId);
      if (!progress) {
        throw new CustomError('Survey progress not found', 404);
      }

      return progress;
    } catch (error) {
      if (error instanceof CustomError) throw error;
      throw new CustomError('Error retrieving survey progress', 500);
    }
  }

  async getSurveyParticipants(surveyId, queryParams) {
    try {
      const filters = {
        status: queryParams.status,

        minProgress: queryParams.minProgress,

        startDate: queryParams.startDate,
        endDate: queryParams.endDate,


        sortBy: queryParams.sortBy || '-updatedAt'
      };

      const participants = await this.repository.getSurveyParticipants(
        surveyId, 
        filters
      );

      return participants;
    } catch (error) {
      throw new CustomError('Error fetching survey participants', 500);
    }
  }


  async getCompletionStats(surveyId) {
    try {
      const survey = await this.surveyService.getSurveyById(surveyId);
      if (!survey) {
        throw new CustomError('Survey not found', 404);
      }

      const stats = await this.repository.getCompletionStats(surveyId);
      return {
        totalParticipants: stats.reduce((acc, stat) => acc + stat.count, 0),
        statusBreakdown: stats.reduce((acc, stat) => {
          acc[stat._id] = {
            count: stat.count,
            percentage: stat.avgProgress
          };
          return acc;
        }, {}),
        averageCompletion: stats.reduce((acc, stat) => acc + stat.avgProgress, 0) / stats.length
      };
    } catch (error) {
      if (error instanceof CustomError) throw error;
      throw new CustomError('Error getting completion statistics', 500);
    }
  }

  async getMyProgress(respondentId) {
    try {
      const progress = await this.repository.findAll({ respondentId });
      return progress.map(p => ({
        surveyId: p.surveyId,
        status: p.status,
        progress: p.progress,
        startedAt: p.startedAt,
        lastAnsweredAt: p.lastAnsweredAt,
        completedAt: p.completedAt
      }));
    } catch (error) {
      throw new CustomError('Error retrieving your survey progress', 500);
    }
  }

  // doubt in this service

  // async resetProgress(surveyId, respondentId) {
  //   try {
  //     const progress = await this.findBySurveyAndRespondent(surveyId, respondentId);
  //     if (!progress) {
  //       throw new CustomError('Survey progress not found', 404);
  //     }

  //     const resetData = {
  //       status: 'NOT_STARTED',
  //       answeredQuestions: [],
  //       progress: 0,
  //       startedAt: null,
  //       completedAt: null,
  //       lastAnsweredAt: new Date()
  //     };

  //     return await this.repository.updateById(progress.id, resetData);
  //   } catch (error) {
  //     if (error instanceof CustomError) throw error;
  //     throw new CustomError('Error resetting survey progress', 500);
  //   }
  // }

  async bulkUpdateProgress(surveyId, respondentId, questionIds) {
    try {
      let progress = await this.findBySurveyAndRespondent(surveyId, respondentId);
      if (!progress) {
        progress = await this.initializeProgress(surveyId, respondentId);
      }

      const survey = await this.surveyService.getSurveyById(surveyId);
      const totalQuestions = survey.questions.length;

      const uniqueQuestions = new Set([
        ...progress.answeredQuestions.map(q => q.toString()),
        ...questionIds.map(q => q.toString())
      ]);
      progress.answeredQuestions = Array.from(uniqueQuestions);

      if (progress.status === 'NOT_STARTED') {
        progress.status = 'IN_PROGRESS';
        progress.startedAt = new Date();
      }

      progress.progress = Math.round((progress.answeredQuestions.length / totalQuestions) * 100);
      progress.lastAnsweredAt = new Date();

      if (progress.progress === 100) {
        progress.status = 'COMPLETED';
        progress.completedAt = new Date();
      }

      return await this.repository.updateById(progress.id, progress);
    } catch (error) {
      if (error instanceof CustomError) throw error;
      throw new CustomError('Error updating survey progress', 500);
    }
  }

  async deleteProgress(surveyId, respondentId) {
    try {
      const progress = await this.findBySurveyAndRespondent(surveyId, respondentId);
      if (!progress) {
        throw new CustomError('Survey progress not found', 404);
      }

      await this.repository.deleteById(progress.id);
      return { message: 'Survey progress deleted successfully' };
    } catch (error) {
      if (error instanceof CustomError) throw error;
      throw new CustomError('Error deleting survey progress', 500);
    }
  }
}

module.exports = SurveyProgressService;

File: service\user.js
----------------------------------------
const BaseService = require('./baseService');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const keys = require('../config/keys');
const CustomError = require('../utils/customError');

class UserService extends BaseService {
  constructor(userRepository) {
    super(userRepository);
  }

  async registerUser(userData) {
    const { username, email, password } = userData;

    let existingUser = await this.repository.findByEmail(email);
    if (existingUser) {
      throw new CustomError('User with this email already exists', 400);
    }

    existingUser = await this.repository.findByUsername(username);
    if (existingUser) {
      throw new CustomError('Username is already taken', 400);
    }

    const user = await this.repository.create({
      username,
      email,
      password
    });

    const token = jwt.sign(
      { id: user._id },
      keys.jwtSecret,
      { expiresIn: '1d' }
    );

    return {
      user: {
        id: user._id,
        username: user.username,
        email: user.email,
        role: user.role
      },
      token
    };
  }

  async loginUser(userData) {
    const { email, password } = userData;

    const user = await this.repository.findByEmail(email);
    if (!user) {
      throw new CustomError('Invalid credentials', 401);
    }

    const isMatch = await user.matchPassword(password);
    if (!isMatch) {
      throw new CustomError('Invalid credentials', 401);
    }

    user.lastLogin = new Date();
    await user.save({ validateBeforeSave: false }); 

    const token = jwt.sign(
      { id: user._id },
      keys.jwtSecret,
      { expiresIn: '1d' }
    );

    return {
      user: {
        id: user._id,
        username: user.username,
        email: user.email,
        role: user.role
      },
      token
    };
  }

  async getUserById(userId) {
    const user = await this.findById(userId);
    if (!user) {
      throw new CustomError('User not found', 404);
    }

    return {
      id: user._id,
      username: user.username,
      email: user.email,
      role: user.role
    };
  }
}

module.exports = UserService;

File: tests\survey.test.js
----------------------------------------
// Load environment variables from config/.env file
require('dotenv').config({ path: 'config/.env' });
const mongoose = require('mongoose');
const Survey = require('../models/survey');
const { surveyController } = require('../bootstrap');

describe('Survey Model', () => {
  beforeAll(async () => {
    const url = process.env.MONGO_URI_TESTING; // Use a different database for testing
    console.log('Connecting to MongoDB:', url);
    await mongoose.connect(url);
  });

  afterAll(async () => {
    await mongoose.connection.close();
  });

  // Test Case for Create Survey
  it('should create a new Survey', async () => {
    const timestamp = Date.now();

    const req = {
      body: {
        title: `Sample Survey ${new Date().getTime()}`,
        description: 'This is a sample survey',
        createdBy: new mongoose.Types.ObjectId(),
        isTemplate: false,
        questions: [],
        questionOrder: []
      }
    };
    const res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn()
    };

    await surveyController.createSurvey(req, res);

    expect(res.status).toHaveBeenCalledWith(201);

    const createdSurvey = res.json.mock.calls[0][0];
    expect(createdSurvey.data.title).toBe(req.body.title);
    expect(createdSurvey.data.description).toBe(req.body.description);
    expect(createdSurvey.data.createdBy).toEqual(req.body.createdBy);
    expect(createdSurvey.data.isTemplate).toBe(req.body.isTemplate);
    expect(Array.isArray(createdSurvey.data.questions)).toBe(true);
    expect(Array.isArray(createdSurvey.data.questionOrder)).toBe(true);

    const surveyInDb = await Survey.findById(createdSurvey.data._id);
    expect(surveyInDb).toBeDefined();
    expect(surveyInDb.title).toBe(req.body.title);
    expect(surveyInDb.description).toBe(req.body.description);
    expect(surveyInDb.createdBy).toEqual(req.body.createdBy);
    expect(surveyInDb.isTemplate).toBe(req.body.isTemplate);
    expect(Array.isArray(surveyInDb.questions)).toBe(true);
    expect(Array.isArray(surveyInDb.questionOrder)).toBe(true);
  });

  // Test Case for Get All Surveys
  it('should get all surveys', async () => {
    const existingSurveys = await Survey.find({});

    const req = {
      query: { includeArchived: 'false' }
    };
    const res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn()
    };

    await surveyController.getAllSurveys(req, res);

    expect(res.status).toHaveBeenCalledWith(200);

    const foundSurveys = res.json.mock.calls[0][0];
    expect(foundSurveys.data.length).toBe(existingSurveys.length);

    // Validate each survey found in the response
    existingSurveys.forEach(existingSurvey => {
      const foundSurvey = foundSurveys.data.find(survey => 
        survey._id.toString() === existingSurvey._id.toString()
      );
      expect(foundSurvey).toBeDefined();
      expect(foundSurvey.title).toBe(existingSurvey.title);
      expect(foundSurvey.description).toBe(existingSurvey.description);
      expect(foundSurvey.createdBy).toEqual(existingSurvey.createdBy);
      expect(foundSurvey.isTemplate).toBe(existingSurvey.isTemplate);
      expect(Array.isArray(foundSurvey.questions)).toBe(true);
      expect(Array.isArray(foundSurvey.questionOrder)).toBe(true);
    });
  });

  // Test Case for Get Survey By ID
  it('should get a survey by id', async () => {
    const existingSurvey = await Survey.findOne();

    const req = {
      params: { id: existingSurvey._id }
    };
    const res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn()
    };

    await surveyController.getById(req, res);

    expect(res.status).toHaveBeenCalledWith(200);

    const foundSurvey = res.json.mock.calls[0][0];
    expect(foundSurvey).toBeDefined();
    expect(foundSurvey.data.title).toBe(existingSurvey.title);
    expect(foundSurvey.data.description).toBe(existingSurvey.description);
    expect(foundSurvey.data.createdBy).toEqual(existingSurvey.createdBy);
    expect(foundSurvey.data.isTemplate).toBe(existingSurvey.isTemplate);
    expect(Array.isArray(foundSurvey.data.questions)).toBe(true);
    expect(Array.isArray(foundSurvey.data.questionOrder)).toBe(true);
  });

  // Test Case for Update Survey By ID
  it('should update a survey by id', async () => {
    const existingSurvey = await Survey.findOne();
    const timestamp = Date.now();

    const updatedSurveyData = {
      title: `Updated Survey ${new Date().getTime()}`,
      description: 'Updated sample description',
      isTemplate: true,
      isArchived: false
    };

    const req = {
      params: { id: existingSurvey._id },
      body: updatedSurveyData,
      user: { id: existingSurvey.createdBy }
    };
    const res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn()
    };

    await surveyController.update(req, res);

    expect(res.status).toHaveBeenCalledWith(200);

    const updatedSurvey = res.json.mock.calls[0][0];
    expect(updatedSurvey.data.title).toBe(updatedSurveyData.title);
    expect(updatedSurvey.data.description).toBe(updatedSurveyData.description);
    expect(updatedSurvey.data.isTemplate).toBe(updatedSurveyData.isTemplate);
    expect(updatedSurvey.data.isArchived).toBe(updatedSurveyData.isArchived);

    // Fetch the survey from the database after update
    const fetchedSurvey = await Survey.findById(existingSurvey._id);
    expect(fetchedSurvey.title).toBe(updatedSurveyData.title);
    expect(fetchedSurvey.description).toBe(updatedSurveyData.description);
    expect(fetchedSurvey.isTemplate).toBe(updatedSurveyData.isTemplate);
    expect(fetchedSurvey.isArchived).toBe(updatedSurveyData.isArchived);
  });

  // Test Case for Delete Survey By ID
  it('should delete a survey by id', async () => {
    const existingSurvey = await Survey.findOne();

    const req = {
      params: { id: existingSurvey._id },
      user: { id: existingSurvey.createdBy }
    };
    const res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn()
    };

    await surveyController.delete(req, res);

    expect(res.status).toHaveBeenCalledWith(200);

    // Verify that the survey is deleted from the database
    const surveyInDb = await Survey.findById(existingSurvey._id);
    expect(surveyInDb).toBeNull();
  });

  // Test Case for Archive Survey
  it('should archive a survey', async () => {
    const existingSurvey = await Survey.findOne();

    const req = {
      params: { id: existingSurvey._id },
      user: { id: existingSurvey.createdBy }
    };
    const res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn()
    };

    await surveyController.archiveSurvey(req, res);

    expect(res.status).toHaveBeenCalledWith(200);

    const archivedSurvey = res.json.mock.calls[0][0];
    expect(archivedSurvey.data.isArchived).toBe(true);
    expect(archivedSurvey.data.archivedAt).toBeDefined();

    // Verify archive status in database
    const surveyInDb = await Survey.findById(existingSurvey._id);
    expect(surveyInDb.isArchived).toBe(true);
    expect(surveyInDb.archivedAt).toBeDefined();
  });

  // Test Case for Duplicate Survey
  it('should duplicate a survey', async () => {
    const existingSurvey = await Survey.findOne();

    const req = {
      params: { id: existingSurvey._id },
      user: { id: existingSurvey.createdBy }
    };
    const res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn()
    };

    await surveyController.duplicateSurvey(req, res);

    expect(res.status).toHaveBeenCalledWith(201);

    const duplicatedSurvey = res.json.mock.calls[0][0];
    expect(duplicatedSurvey.data.title).toBe(`${existingSurvey.title} (Copy)`);
    expect(duplicatedSurvey.data.description).toBe(existingSurvey.description);
    expect(duplicatedSurvey.data.isTemplate).toBe(existingSurvey.isTemplate);
    expect(duplicatedSurvey.data.questions.length).toBe(existingSurvey.questions.length);

    // Verify duplicate exists in database
    const duplicateInDb = await Survey.findById(duplicatedSurvey.data._id);
    expect(duplicateInDb).toBeDefined();
    expect(duplicateInDb.title).toBe(`${existingSurvey.title} (Copy)`);
    expect(duplicateInDb.questions.length).toBe(existingSurvey.questions.length);
  });

  // Test Case for Reorder Questions
  it('should reorder questions in a survey', async () => {
    const existingSurvey = await Survey.findOne({ 'questions.0': { $exists: true } });
    
    if (existingSurvey && existingSurvey.questions.length >= 2) {
      const newQuestionOrder = [...existingSurvey.questionOrder].reverse();

      const req = {
        params: { id: existingSurvey._id },
        body: { questionOrder: newQuestionOrder },
        user: { id: existingSurvey.createdBy }
      };
      const res = {
        status: jest.fn().mockReturnThis(),
        json: jest.fn()
      };

      await surveyController.reorderQuestions(req, res);

      expect(res.status).toHaveBeenCalledWith(200);

      const updatedSurvey = res.json.mock.calls[0][0];
      expect(updatedSurvey.data.questionOrder).toEqual(newQuestionOrder);

      const surveyInDb = await Survey.findById(existingSurvey._id);
      expect(surveyInDb.questionOrder.map(id => id.toString()))
        .toEqual(newQuestionOrder.map(id => id.toString()));
    }
  });
});

File: utils\customError.js
----------------------------------------
class CustomError extends Error {
  constructor(message, statusCode) {
      super(message);
      this.statusCode = statusCode;
      this.status = `${statusCode}`.startsWith('4') ? 'fail' : 'error';
      this.isOperational = true;

      Error.captureStackTrace(this, this.constructor);
  }
}

module.exports = CustomError;

File: utils\formatResponse.js
----------------------------------------
const formatResponse = (data, message = '') => {
  return {
    success: true,
    message,
    data
  };
};

module.exports = formatResponse;
  

File: utils\generateToken.js
----------------------------------------
const jwt = require('jsonwebtoken');
const keys = require('../config/keys');

const generateToken = (userId) => {
  return jwt.sign(
    { id: userId },
    keys.jwtSecret,
    { expiresIn: '1d' }
  );
};

module.exports = generateToken;

