File: bootstrap.js
----------------------------------------
const SurveyRepository = require('./repositories/survey');
const QuestionRepository = require('./repositories/question');
const AnswerRepository = require('./repositories/answer');
const UserRepository = require('./repositories/user');
const SurveyProgressRepository = require('./repositories/surveyProgress');

const SurveyService = require('./service/survey');
const QuestionService = require('./service/question');
const AnswerService = require('./service/answer');
const UserService = require('./service/user');
const SurveyProgressService = require('./service/surveyProgress');

const SurveyController = require('./controller/survey');
const QuestionController = require('./controller/question');
const AnswerController = require('./controller/answer');
const UserController = require('./controller/user');
const SurveyProgressController = require('./controller/surveyProgress');

// Initialize repositories
const surveyRepository = new SurveyRepository();
const questionRepository = new QuestionRepository();
const answerRepository = new AnswerRepository();
const userRepository = new UserRepository();
const surveyProgressRepository = new SurveyProgressRepository();

const surveyService = new SurveyService(surveyRepository);
const questionService = new QuestionService(questionRepository, surveyService);
surveyService.setQuestionService(questionService);

const answerService = new AnswerService(answerRepository, questionService, surveyService);
const userService = new UserService(userRepository);
const surveyProgressService = new SurveyProgressService(
  surveyProgressRepository,
  surveyService,
  questionService
);

const surveyController = new SurveyController(surveyService);
const questionController = new QuestionController(questionService);
const answerController = new AnswerController(answerService);
const userController = new UserController(userService);
const surveyProgressController = new SurveyProgressController(surveyProgressService);

module.exports = {
  surveyController,
  questionController,
  answerController,
  userController,
  surveyProgressController,
};

File: config\keys.js
----------------------------------------
require('dotenv').config();

module.exports = {
  mongoURI: process.env.MONGODB_URI || 'mongodb://localhost:27017/survey',
  jwtSecret: process.env.JWT_SECRET || 'secret',
  port: process.env.PORT || 5000,
  // nodeEnv: process.env.NODE_ENV || 'development'
};

File: controller\answer.js
----------------------------------------
const BaseController = require('./baseController');
const asyncHandler = require('../middleware/asyncHandler');
const formatResponse = require('../utils/formatResponse');


class AnswerController extends BaseController {
    constructor(answerService) {
      super(answerService);
    }
  
    submitAnswer = asyncHandler(async (req, res) => {
      const answer = await this.service.createAnswer({
        ...req.body,
        questionId: req.params.questionId,
        respondentId: req.user.id,
        createdBy: req.user.id
      });
      res.status(201).json(formatResponse(answer));
    });
  
    getAnswersBySurvey = asyncHandler(async (req, res) => {
      const answers = await this.service.getAnswersBySurvey(
        req.params.surveyId,
        req.user.id
      );
      res.status(200).json(formatResponse(answers));
    });
  
    getAnswersByQuestion = asyncHandler(async (req, res) => {
      const answers = await this.service.getAnswersByQuestion(req.params.questionId);
      res.status(200).json(formatResponse(answers));
    });
  
    getMyAnswers = asyncHandler(async (req, res) => {
      const answers = await this.service.getRespondentAnswers(
        req.params.surveyId,
        req.user.id
      );
      res.status(200).json(formatResponse(answers));
    });
  
    getSurveyStats = asyncHandler(async (req, res) => {
      const stats = await this.service.getSurveyStats(req.params.surveyId);
      res.status(200).json(formatResponse(stats));
    });
  
    deleteAnswer = asyncHandler(async (req, res) => {
      await this.service.deleteAnswer(
        req.params.answerId,
        req.user.id,
        req.user.role
      );
      res.status(200).json(formatResponse({ message: 'Answer deleted successfully' }));
    });
  }

module.exports = AnswerController;

File: controller\baseController.js
----------------------------------------
const asyncHandler = require('../middleware/asyncHandler');
const formatResponse = require('../utils/formatResponse');

class BaseController {
  constructor(service) {
    this.service = service;
  }

  getAll = asyncHandler(async (req, res) => {
    const items = await this.service.findAll(req.query);
    res.status(200).json(formatResponse(items));
  });

  getById = asyncHandler(async (req, res) => {
    const item = await this.service.findById(req.params.id);
    res.status(200).json(formatResponse(item));
  });

  create = asyncHandler(async (req, res) => {
    const item = await this.service.create({
      ...req.body,
      createdBy: req.user.id
    });
    res.status(201).json(formatResponse(item));
  });

  update = asyncHandler(async (req, res) => {
    const item = await this.service.updateById(req.params.id, {
      ...req.body,
      modifiedBy: req.user.id
    });
    res.status(200).json(formatResponse(item));
  });

  delete = asyncHandler(async (req, res) => {
    await this.service.deleteById(req.params.id);
    res.status(200).json(formatResponse({ message: 'Resource deleted successfully' }));
  });
}

module.exports = BaseController;

File: controller\question.js
----------------------------------------
const BaseController = require('./baseController');
const asyncHandler = require('../middleware/asyncHandler');
const formatResponse = require('../utils/formatResponse');

class QuestionController extends BaseController {
  constructor(questionService) {
    super(questionService);
  }

  createQuestion = asyncHandler(async (req, res) => {
    const question = await this.service.createQuestion({
      ...req.body,
      surveyId: req.params.surveyId,
      createdBy: req.user.id
    });
    res.status(201).json(formatResponse(question));
  });

  updateQuestion = asyncHandler(async (req, res) => {
    const question = await this.service.updateQuestion(req.params.id, {
      ...req.body,
      modifiedBy: req.user.id
    });
    res.status(200).json(formatResponse(question));
  });

  moveQuestion = asyncHandler(async (req, res) => {
    const { direction } = req.body;
    const question = await this.service.moveQuestion(
      req.params.surveyId,
      req.params.id,
      direction
    );
    res.status(200).json(formatResponse(question));
  });
}

module.exports = QuestionController;

File: controller\survey.js
----------------------------------------
const BaseController = require('./baseController');
const asyncHandler = require('../middleware/asyncHandler');
const formatResponse = require('../utils/formatResponse');

class SurveyController extends BaseController {
  constructor(surveyService) {
    super(surveyService);
  }

  getAllSurveys = asyncHandler(async (req, res) => {
    if (req.query.includeArchived !== 'true') {
      req.query.isArchived = false;
    }
    delete req.query.includeArchived;

    const surveys = await this.service.getAllSurveys(req.query);
    res.status(200).json(formatResponse(surveys));
  });

  createSurvey = asyncHandler(async (req, res) => {
    const survey = await this.service.createSurvey({
      ...req.body,
      createdBy: req.user.id
    });
    res.status(201).json(formatResponse(survey));
  });

  duplicateSurvey = asyncHandler(async (req, res) => {
    const survey = await this.service.duplicateSurvey(
      req.params.id,
      req.user.id
    );
    res.status(201).json(formatResponse(survey));
  });

  archiveSurvey = asyncHandler(async (req, res) => {
    const survey = await this.service.archiveSurvey(
      req.params.id,
      req.user.id
    );
    res.status(200).json(formatResponse(survey));
  });

  unarchiveSurvey = asyncHandler(async (req, res) => {
    const survey = await this.service.unarchiveSurvey(
      req.params.id,
      req.user.id
    );
    res.status(200).json(formatResponse(survey));
  });

  reorderQuestions = asyncHandler(async (req, res) => {
    const survey = await this.service.reorderQuestions(
      req.params.id,
      req.body.questionOrder
    );
    res.status(200).json(formatResponse(survey));
  });
}

module.exports = SurveyController;

File: controller\surveyProgress.js
----------------------------------------
const BaseController = require('./baseController');
const asyncHandler = require('../middleware/asyncHandler');
const formatResponse = require('../utils/formatResponse');

class SurveyProgressController extends BaseController {
  constructor(surveyProgressService) {
    super(surveyProgressService);
  }

  initializeProgress = asyncHandler(async (req, res) => {
    const progress = await this.service.initializeProgress(
      req.params.surveyId,
      req.user.id
    );
    res.status(200).json(formatResponse(progress));
  });

  updateProgress = asyncHandler(async (req, res) => {
    const progress = await this.service.updateProgress(
      req.params.surveyId,
      req.user.id,
      req.params.questionId
    );
    res.status(200).json(formatResponse(progress));
  });

  getProgress = asyncHandler(async (req, res) => {
    const progress = await this.service.getProgress(
      req.params.surveyId,
      req.user.id
    );
    res.status(200).json(formatResponse(progress));
  });

  getParticipants = asyncHandler(async (req, res) => {
    const participants = await this.service.getSurveyParticipants(
      req.params.surveyId,
      req.user.id
    );
    res.status(200).json(formatResponse(participants));
  });

  getCompletionStats = asyncHandler(async (req, res) => {
    const stats = await this.service.getCompletionStats(
      req.params.surveyId,
      req.user.id
    );
    res.status(200).json(formatResponse(stats));
  });

  getMyProgress = asyncHandler(async (req, res) => {
    const progress = await this.service.getRespondentProgress(req.user.id);
    res.status(200).json(formatResponse(progress));
  });
}

module.exports = SurveyProgressController;

File: controller\user.js
----------------------------------------
const asyncHandler = require('../middleware/asyncHandler');
const formatResponse = require('../utils/formatResponse');

class UserController {
  constructor(userService) {
    this.userService = userService;
  }

  registerUser = asyncHandler(async (req, res, next) => {
    const userData = req.body;
    const { user, token } = await this.userService.registerUser(userData);

    res.status(201).json(formatResponse({ user, token }));
  });

  loginUser = asyncHandler(async (req, res, next) => {
    const userData = req.body;
    const { user, token } = await this.userService.loginUser(userData);

    res.status(200).json(formatResponse({ user, token }));
  });

  getCurrentUser = asyncHandler(async (req, res, next) => {
    const user = await this.userService.getUserById(req.user.id);

    res.status(200).json(formatResponse(user));
  });
}

module.exports = UserController;


File: index.js
----------------------------------------
require('dotenv').config();
const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const helmet = require('helmet');
const keys = require('./config/keys');
const authMiddleware = require('./middleware/auth');
const errorHandler = require('./middleware/errorHandler');

const app = express();

// Middleware
app.use(helmet());
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Database Connection
mongoose
  .connect(keys.mongoURI, {
    useNewUrlParser: true,
    useUnifiedTopology: true,
  })
  .then(() => console.log('MongoDB Connected'))
  .catch((err) => console.error('MongoDB Connection Error:', err));

// Routes
const userRoutes = require('./routes/user');
const surveyRoutes = require('./routes/survey');
const questionRoutes = require('./routes/question');
const answerRoutes = require('./routes/answer');
const surveyProgressRoutes = require('./routes/surveyProgress');

app.use('/api/users', userRoutes);
app.use('/api/surveys', authMiddleware, surveyRoutes);
app.use('/api/questions', authMiddleware, questionRoutes);
app.use('/api/answers', authMiddleware, answerRoutes);
app.use('/api/survey-progress', authMiddleware, surveyProgressRoutes);

// Error Handler
app.use(errorHandler);

const PORT = keys.port;
app.listen(PORT, () => console.log(`Server running on port ${PORT}`));

File: middleware\asyncHandler.js
----------------------------------------
const asyncHandler = fn => (req, res, next) =>
    Promise.resolve(fn(req, res, next)).catch(next);
  
  module.exports = asyncHandler;
  
  

File: middleware\auth.js
----------------------------------------
const jwt = require('jsonwebtoken');
const CustomError = require('../utils/customError');
const keys = require('../config/keys');
const User = require('../models/user');

const protect = async (req, res, next) => {
  try {
    let token;

    if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
      token = req.headers.authorization.split(' ')[1];
    }

    if (!token) {
      throw new CustomError('Not authorized to access this route', 401);
    }

    const decoded = jwt.verify(token, keys.jwtSecret);
    req.user = await User.findById(decoded.id).select('-password');

    if (!req.user) {
      throw new CustomError('User not found', 404);
    }

    next();
  } catch (err) {
    next(new CustomError('Authentication failed', 401));
  }
};

module.exports = protect;

File: middleware\checkOwnership.js
----------------------------------------
const CustomError = require('../utils/customError');

const checkOwnership = (modelName) => async (req, res, next) => {
  const Model = require(`../models/${modelName.toLowerCase()}`);
  const resource = await Model.findById(req.params.id);

  if (!resource) {
    throw new CustomError(`${modelName} not found`, 404);
  }

  if (resource.createdBy.toString() !== req.user.id && req.user.role !== 'admin') {
    throw new CustomError(`Not authorized to modify this ${modelName}`, 403);
  }

  req.resource = resource;
  next();
};

module.exports = checkOwnership;

File: middleware\errorHandler.js
----------------------------------------
const CustomError = require('../utils/customError');

const errorHandler = (err, req, res, next) => {
  let error = { ...err };
  error.message = err.message;

  console.error(err);

  if (err.name === 'CastError') {
    error = new CustomError('Resource not found', 404);
  }

  if (err.code === 11000) {
    error = new CustomError('Duplicate field value entered', 400);
  }

  if (err.name === 'ValidationError') {
    const message = Object.values(err.errors).map(val => val.message).join(', ');
    error = new CustomError(message, 400);
  }

  res.status(error.statusCode || 500).json({
    success: false,
    error: error.message || 'Server Error'
  });
};

module.exports = errorHandler;

File: middleware\rateLimiter.js
----------------------------------------
const rateLimit = require('express-rate-limit');
const CustomError = require('../utils/customError');

const createRateLimiter = (windowMs, max, message) => {
  return rateLimit({
    windowMs,
    max,
    handler: (req, res) => {
      throw new CustomError(message || 'Too many requests, please try again later', 429);
    }
  });
};

const authLimiter = createRateLimiter(
  15 * 60 * 1000, // 15 minutes
  5,
  'Too many login attempts, please try again after 15 minutes'
);

const apiLimiter = createRateLimiter(
  60 * 1000, // 1 minute
  100,
  'Too many requests, please try again after a minute'
);

module.exports = {
  authLimiter,
  apiLimiter
};

File: middleware\validateDocument.js
----------------------------------------
const CustomError = require('../utils/customError');

const validateDocument = (Model, filterFunction) => {
  return async (req, res, next) => {
    try {
      const filter = filterFunction(req);
      const document = await Model.findOne(filter);

      if (!document) {
        return next(new CustomError('Resource not found', 404));
      }

      req.document = document;
      next();
    } catch (err) {
      next(err);
    }
  };
};

module.exports = validateDocument;

File: middleware\validation.js
----------------------------------------
const Joi = require('joi');
const CustomError = require('../utils/customError');

const validateRequest = (schema) => {
  return (req, res, next) => {
    const { error } = schema.validate(req.body, {
      abortEarly: false,
      stripUnknown: true
    });

    if (error) {
      const errorMessage = error.details
        .map(detail => detail.message)
        .join(', ');
      throw new CustomError(errorMessage, 400);
    }

    next();
  };
};

const schemas = {
  survey: {
    create: Joi.object({
      title: Joi.string()
        .required()
        .max(500)
        .trim()
        .messages({
          'string.empty': 'Title cannot be empty',
          'string.max': 'Title cannot exceed 500 characters'
        }),
      description: Joi.string()
        .allow('')
        .trim(),
      isTemplate: Joi.boolean()
        .default(false)
    }),

    update: Joi.object({
      title: Joi.string()
        .max(500)
        .trim(),
      description: Joi.string()
        .allow('')
        .trim(),
      isTemplate: Joi.boolean(),
      isArchived: Joi.boolean()
    }),

    reorderQuestions: Joi.object({
      questionOrder: Joi.array()
        .items(Joi.string().regex(/^[0-9a-fA-F]{24}$/))
        .required()
        .messages({
          'array.base': 'Question order must be an array',
          'string.pattern.base': 'Invalid question ID format'
        })
    })
  },

  question: {
    create: Joi.object({
      questionText: Joi.string()
        .required()
        .trim()
        .messages({
          'string.empty': 'Question text cannot be empty'
        }),
      responseType: Joi.string()
        .required()
        .valid('text', 'multiple-choice', 'single-choice', 'rating', 'boolean'),
      allowMultiple: Joi.when('responseType', {
        is: 'multiple-choice',
        then: Joi.boolean().required(),
        otherwise: Joi.boolean().valid(false)
      }),
      isMandatory: Joi.boolean()
        .default(false),
      responseValues: Joi.when('responseType', {
        is: Joi.string().valid('multiple-choice', 'single-choice'),
        then: Joi.array()
          .items(Joi.string().required())
          .min(2)
          .required()
          .messages({
            'array.min': 'At least 2 response options are required',
            'array.required': 'Response options are required for choice questions'
          }),
        otherwise: Joi.forbidden()
      })
    }),

    update: Joi.object({
      questionText: Joi.string()
        .trim(),
      isMandatory: Joi.boolean(),
      responseValues: Joi.array()
        .items(Joi.string())
    })
  },

  answer: {
    submit: Joi.object({
      answerValue: Joi.alternatives()
        .try(
          Joi.string(),
          Joi.array().items(Joi.string()),
          Joi.number().min(1).max(5),
          Joi.boolean()
        )
        .required()
        .messages({
          'alternatives.match': 'Invalid answer format for this question type'
        })
    })
  },

  user: {
    register: Joi.object({
      username: Joi.string()
        .required()
        .min(3)
        .max(30)
        .trim()
        .messages({
          'string.min': 'Username must be at least 3 characters',
          'string.max': 'Username cannot exceed 30 characters'
        }),
      email: Joi.string()
        .required()
        .email()
        .messages({
          'string.email': 'Please provide a valid email'
        }),
      password: Joi.string()
        .required()
        .min(6)
        .pattern(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/)
        .messages({
          'string.min': 'Password must be at least 6 characters',
          'string.pattern.base': 'Password must contain at least one uppercase letter, one lowercase letter, and one number'
        })
    }),

    login: Joi.object({
      email: Joi.string()
        .required()
        .email(),
      password: Joi.string()
        .required()
    })
  }
};

module.exports = {
  validateSurvey: validateRequest(schemas.survey.create),
  validateSurveyUpdate: validateRequest(schemas.survey.update),
  validateQuestion: validateRequest(schemas.question.create),
  validateQuestionUpdate: validateRequest(schemas.question.update),
  validateAnswer: validateRequest(schemas.answer.submit),
  validateUserRegister: validateRequest(schemas.user.register),
  validateUserLogin: validateRequest(schemas.user.login),
  validateReorderQuestions: validateRequest(schemas.survey.reorderQuestions)
};

File: models\answer.js
----------------------------------------
const mongoose = require('mongoose');
const { baseModelOptions, baseSchemaFields } = require('./baseModel');

const AnswerSchema = new mongoose.Schema({
  questionId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Question',
    required: true
  },
  surveyId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Survey',
    required: true
  },
  respondentId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  answerValue: {
    type: mongoose.Schema.Types.Mixed,
    required: true
  },
  isValid: {
    type: Boolean,
    default: false
  },
  validatedAt: {
    type: Date
  },
  ...baseSchemaFields
}, baseModelOptions);

AnswerSchema.index({ questionId: 1, respondentId: 1 }, { unique: true });
AnswerSchema.index({ surveyId: 1 });
AnswerSchema.index({ createdAt: 1 });

module.exports = mongoose.model('Answer', AnswerSchema);

File: models\baseModel.js
----------------------------------------
const mongoose = require('mongoose');

const baseModelOptions = {
  timestamps: true,
  toJSON: {
    virtuals: true,
    transform: function(doc, ret) {
      delete ret.__v;
      ret.id = ret._id;
      delete ret._id;
    }
  },
  toObject: {
    virtuals: true
  }
};

const baseSchemaFields = {
  createdBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: false
  },
  modifiedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: false
  },
  isActive: {
    type: Boolean,
    default: true
  }
};

module.exports = {
  baseModelOptions,
  baseSchemaFields
};

File: models\question.js
----------------------------------------
const mongoose = require('mongoose');
const { baseModelOptions, baseSchemaFields } = require('./baseModel');

const ResponseValueSchema = new mongoose.Schema({
  value: {
    type: String,
    required: [true, 'Please add a response value'],
    trim: true
  },
  order: {
    type: Number,
    default: 0
  }
}, { _id: false });

const QuestionSchema = new mongoose.Schema({
  surveyId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Survey',
    required: true
  },
  questionText: {
    type: String,
    required: [true, 'Please add the question text'],
    trim: true
  },
  responseType: {
    type: String,
    enum: ['text', 'multiple-choice', 'single-choice', 'rating', 'boolean'],
    required: [true, 'Please specify the response type']
  },
  responseValues: [ResponseValueSchema],
  allowMultiple: {
    type: Boolean,
    default: false
  },
  isMandatory: {
    type: Boolean,
    default: false
  },
  order: {
    type: Number,
    required: true
  },
  ...baseSchemaFields
}, baseModelOptions);

QuestionSchema.index({ surveyId: 1, order: 1 });
QuestionSchema.index({ createdBy: 1 });

QuestionSchema.pre('save', function(next) {
  if (this.responseType === 'multiple-choice' || this.responseType === 'single-choice') {
    if (!this.responseValues || this.responseValues.length === 0) {
      next(new Error('Response values are required for choice questions'));
    }
  } else {
    this.responseValues = [];
    this.allowMultiple = false;
  }
  next();
});

module.exports = mongoose.model('Question', QuestionSchema);

File: models\survey.js
----------------------------------------
const mongoose = require('mongoose');
const { baseModelOptions, baseSchemaFields } = require('./baseModel');

const SurveySchema = new mongoose.Schema({
  title: {
    type: String,
    required: [true, 'Please add a title'],
    unique: true,
    trim: true,
    maxlength: [500, 'Title cannot exceed 500 characters']
  },
  description: {
    type: String,
    trim: true
  },
  isTemplate: {
    type: Boolean,
    default: false
  },
  isArchived: {
    type: Boolean,
    default: false
  },
  archivedAt: {
    type: Date
  },
  questionOrder: [{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Question'
  }],
  questions: [{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Question'
  }],
  ...baseSchemaFields
}, baseModelOptions);

SurveySchema.index({ title: 1 }, { unique: true });
SurveySchema.index({ createdBy: 1 });
SurveySchema.index({ isArchived: 1 });

module.exports = mongoose.model('Survey', SurveySchema);

File: models\surveyProgress.js
----------------------------------------
const mongoose = require('mongoose');
const { baseModelOptions, baseSchemaFields } = require('./baseModel');

const SurveyProgressSchema = new mongoose.Schema({
  surveyId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Survey',
    required: true
  },
  respondentId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  status: {
    type: String,
    enum: ['NOT_STARTED', 'IN_PROGRESS', 'COMPLETED'],
    default: 'NOT_STARTED'
  },
  startedAt: {
    type: Date
  },
  completedAt: {
    type: Date
  },
  lastAnsweredAt: {
    type: Date
  },
  answeredQuestions: [{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Question'
  }],
  progress: {
    type: Number,
    default: 0,
    min: 0,
    max: 100
  },
  ...baseSchemaFields
}, baseModelOptions);

// Indexes for better query performance
SurveyProgressSchema.index({ surveyId: 1, respondentId: 1 }, { unique: true });
SurveyProgressSchema.index({ status: 1 });
SurveyProgressSchema.index({ completedAt: 1 });
SurveyProgressSchema.index({ respondentId: 1, status: 1 });

// Update timestamps on status change
SurveyProgressSchema.pre('save', function(next) {
  if (this.isModified('status')) {
    if (this.status === 'IN_PROGRESS' && !this.startedAt) {
      this.startedAt = new Date();
    } else if (this.status === 'COMPLETED' && !this.completedAt) {
      this.completedAt = new Date();
    }
  }
  if (this.isModified('answeredQuestions')) {
    this.lastAnsweredAt = new Date();
  }
  next();
});

// Methods to check progress status
SurveyProgressSchema.methods.isCompleted = function() {
  return this.status === 'COMPLETED';
};

SurveyProgressSchema.methods.isStarted = function() {
  return this.status !== 'NOT_STARTED';
};

module.exports = mongoose.model('SurveyProgress', SurveyProgressSchema);

File: models\user.js
----------------------------------------
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');
const { baseModelOptions } = require('./baseModel');

const UserSchema = new mongoose.Schema({
  username: {
    type: String,
    required: [true, 'Please add a username'],
    unique: true,
    trim: true,
    minlength: [3, 'Username must be at least 3 characters long'],
    maxlength: [30, 'Username cannot exceed 30 characters']
  },
  email: {
    type: String,
    required: [true, 'Please add an email'],
    unique: true,
    trim: true,
    lowercase: true,
    match: [
      /^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/,
      'Please add a valid email'
    ]
  },
  password: {
    type: String,
    required: [true, 'Please add a password'],
    minlength: [6, 'Password must be at least 6 characters long'],
    select: false
  },
  role: {
    type: String,
    enum: ['user', 'admin'],
    default: 'user'
  },
  lastLogin: {
    type: Date
  }
}, baseModelOptions);

UserSchema.pre('save', async function(next) {
  if (!this.isModified('password')) {
    return next();
  }
  const salt = await bcrypt.genSalt(10);
  this.password = await bcrypt.hash(this.password, salt);
  next();
});

UserSchema.methods.matchPassword = async function(enteredPassword) {
  return await bcrypt.compare(enteredPassword, this.password);
};

module.exports = mongoose.model('User', UserSchema);

File: repositories\answer.js
----------------------------------------
const BaseRepository = require('./baseRepository');
const Answer = require('../models/answer');

class AnswerRepository extends BaseRepository {
  constructor() {
    super(Answer);
  }

  async findBySurveyAndRespondent(surveyId, respondentId) {
    return await this.model
      .find({ surveyId, respondentId })
      .populate('questionId');
  }

  async findQuestionAnswers(questionId) {
    return await this.model
      .find({ questionId })
      .populate('respondentId', 'username email');
  }
}

module.exports = AnswerRepository;

File: repositories\baseRepository.js
----------------------------------------
class BaseRepository {
    constructor(model) {
      this.model = model;
    }
  
    async create(data) {
      return await this.model.create(data);
    }
  
    async findById(id, populate = '') {
      return await this.model.findById(id).populate(populate);
    }
  
    async findOne(filter = {}, populate = '') {
      return await this.model.findOne(filter).populate(populate);
    }
  
    async findAll(filter = {}, options = {}) {
      const { sort = {}, populate = '', limit = 0, skip = 0 } = options;
      return await this.model
        .find(filter)
        .sort(sort)
        .populate(populate)
        .limit(limit)
        .skip(skip);
    }
  
    async updateById(id, data) {
      return await this.model.findByIdAndUpdate(
        id,
        data,
        { new: true, runValidators: true }
      );
    }
  
    async deleteById(id) {
      return await this.model.findByIdAndDelete(id);
    }
  
    async deleteMany(filter = {}) {
      return await this.model.deleteMany(filter);
    }
  
    async count(filter = {}) {
      return await this.model.countDocuments(filter);
    }
  }
  
  module.exports = BaseRepository;

File: repositories\question.js
----------------------------------------
const BaseRepository = require('./baseRepository');
const Question = require('../models/question');

class QuestionRepository extends BaseRepository {
  constructor() {
    super(Question);
  }

  async findBySurveyId(surveyId) {
    return await this.model
      .find({ surveyId })
      .sort('order');
  }

  async getMaxOrder(surveyId) {
    const result = await this.model
      .findOne({ surveyId })
      .sort('-order')
      .select('order');
    return result ? result.order : 0;
  }

  async reorderQuestions(surveyId, questionOrder) {
    const bulkOps = questionOrder.map((questionId, index) => ({
      updateOne: {
        filter: { _id: questionId, surveyId },
        update: { $set: { order: index } }
      }
    }));

    return await this.model.bulkWrite(bulkOps);
  }
}

module.exports = QuestionRepository;

File: repositories\survey.js
----------------------------------------
const BaseRepository = require('./baseRepository');
const Survey = require('../models/survey');
const mongoose = require('mongoose');
class SurveyRepository extends BaseRepository {
  constructor() {
    super(Survey);
  }

  async findByIdWithQuestions(id) {
    return await this.model
      .findById(id)
      .populate({
        path: 'questions',
        options: { sort: { order: 1 } }
      });
  }

  async findAllWithQuestions(filter = {}) {
    return await this.model
      .find(filter)
      .populate({
        path: 'questions',
        options: { sort: { order: 1 } }
      });
  }
}

module.exports = SurveyRepository;

File: repositories\surveyProgress.js
----------------------------------------
const BaseRepository = require('./baseRepository');
const SurveyProgress = require('../models/surveyProgress');
const mongoose = require('mongoose');

class SurveyProgressRepository extends BaseRepository {
  constructor() {
    super(SurveyProgress);
  }

  async findBySurveyAndRespondent(surveyId, respondentId) {
    return await this.model
      .findOne({ surveyId, respondentId })
      .populate('answeredQuestions');
  }

  async findBySurveyWithRespondents(surveyId) {
    return await this.model
      .find({ surveyId })
      .populate('respondentId', 'username email')
      .sort('-updatedAt');
  }

  async findByRespondent(respondentId) {
    return await this.model
      .find({ respondentId })
      .populate('surveyId', 'title')
      .sort('-updatedAt');
  }

  async updateProgress(surveyId, respondentId, questionId) {
    const progress = await this.findBySurveyAndRespondent(surveyId, respondentId);
    
    if (!progress) {
      return null;
    }

    if (!progress.answeredQuestions.includes(questionId)) {
      progress.answeredQuestions.push(questionId);
    }

    if (progress.status === 'NOT_STARTED') {
      progress.status = 'IN_PROGRESS';
    }

    return await progress.save();
  }

  async markAsCompleted(surveyId, respondentId) {
    return await this.model.findOneAndUpdate(
      { surveyId, respondentId },
      { 
        status: 'COMPLETED',
        completedAt: new Date(),
        modifiedBy: respondentId
      },
      { new: true }
    );
  }

  async getCompletionStats(surveyId) {
    const stats = await this.model.aggregate([
      { $match: { surveyId: mongoose.Types.ObjectId(surveyId) } },
      { 
        $group: {
          _id: '$status',
          count: { $sum: 1 },
          avgProgress: { $avg: '$progress' }
        }
      }
    ]);

    return stats.reduce((acc, stat) => {
      acc[stat._id.toLowerCase()] = {
        count: stat.count,
        avgProgress: Math.round(stat.avgProgress)
      };
      return acc;
    }, {});
  }

  async getSurveyParticipants(surveyId, filters = {}) {
    const query = { surveyId, ...filters };
    
    return await this.model
      .find(query)
      .populate('respondentId', 'username email')
      .populate('surveyId', 'title')
      .sort('-updatedAt');
  }

  async getRespondentProgress(respondentId, filters = {}) {
    const query = { respondentId, ...filters };

    return await this.model
      .find(query)
      .populate('surveyId', 'title description')
      .sort('-updatedAt');
  }

  async deleteAllProgressForSurvey(surveyId) {
    return await this.model.deleteMany({ surveyId });
  }
}

module.exports = SurveyProgressRepository;

File: repositories\user.js
----------------------------------------
const BaseRepository = require('./baseRepository');
const User = require('../models/user');

class UserRepository extends BaseRepository {
  constructor() {
    super(User);
  }

  async findByUsername(username) {
    return await this.model.findOne({ username }).select('+password');
  }

  async findByEmail(email) {
    return await this.model.findOne({ email }).select('+password');
  }
}

module.exports = UserRepository


File: routes\answer.js
----------------------------------------
// routes/answer.js
const express = require('express');
const router = express.Router();
const { answerController } = require('../bootstrap');
const auth = require('../middleware/auth');
const { validateAnswer } = require('../middleware/validation');

router.use(auth); // Apply auth middleware to all routes

// Submit an answer for a question
router.post(
  '/questions/:questionId',
  validateAnswer,
  answerController.submitAnswer
);

// Get all answers for a survey
router.get(
  '/surveys/:surveyId',
  answerController.getAnswersBySurvey
);

// Get current user's answers for a survey
router.get(
  '/surveys/:surveyId/my-answers',
  answerController.getMyAnswers
);

// Get all answers for a specific question
router.get(
  '/questions/:questionId',
  answerController.getAnswersByQuestion
);

// Get answer statistics for a survey
router.get(
  '/surveys/:surveyId/stats',
  answerController.getSurveyStats
);

// Delete an answer (only by answer creator or admin)
router.delete(
  '/:answerId',
  answerController.deleteAnswer
);

module.exports = router;

File: routes\question.js
----------------------------------------
const express = require('express');
const router = express.Router();
const { questionController } = require('../bootstrap');
const auth = require('../middleware/auth');
const { 
  validateQuestion, 
  validateQuestionUpdate 
} = require('../middleware/validation');
const checkOwnership = require('../middleware/checkOwnership');

router.use(auth);

router.route('/')
  .post(validateQuestion, questionController.create);

router.route('/:id')
  .get(questionController.getById)
  .put(checkOwnership('Question'), validateQuestionUpdate, questionController.updateQuestion)
  .delete(checkOwnership('Question'), questionController.delete);

router.put('/:id/move', 
  checkOwnership('Question'), 
  questionController.moveQuestion
);

module.exports = router;

File: routes\survey.js
----------------------------------------
const express = require('express');
const router = express.Router();
const { surveyController } = require('../bootstrap');
const auth = require('../middleware/auth');
const { 
  validateSurvey, 
  validateSurveyUpdate, 
  validateReorderQuestions 
} = require('../middleware/validation');
const checkOwnership = require('../middleware/checkOwnership');

router.use(auth);

router.route('/')
  .get(surveyController.getAllSurveys)
  .post(validateSurvey, surveyController.createSurvey);

router.route('/:id')
  .get(surveyController.getById)
  .put(checkOwnership('Survey'), validateSurveyUpdate, surveyController.update)
  .delete(checkOwnership('Survey'), surveyController.delete);

router.post('/:id/duplicate', surveyController.duplicateSurvey);
router.put('/:id/archive', checkOwnership('Survey'), surveyController.archiveSurvey);
router.put('/:id/unarchive', checkOwnership('Survey'), surveyController.unarchiveSurvey);
router.put('/:id/reorder-questions', 
  checkOwnership('Survey'), 
  validateReorderQuestions, 
  surveyController.reorderQuestions
);

module.exports = router;

File: routes\surveyProgress.js
----------------------------------------
// routes/surveyProgress.js
const express = require('express');
const router = express.Router();
const { surveyProgressController } = require('../bootstrap');
const auth = require('../middleware/auth');

router.use(auth);

// Initialize progress for a survey
router.post(
  '/surveys/:surveyId/initialize',
  surveyProgressController.initializeProgress
);

// Update progress after answering a question
router.put(
  '/surveys/:surveyId/questions/:questionId',
  surveyProgressController.updateProgress
);

// Get progress for a specific survey
router.get(
  '/surveys/:surveyId',
  surveyProgressController.getProgress
);

// Get all participants for a survey
router.get(
  '/surveys/:surveyId/participants',
  surveyProgressController.getParticipants
);

// Get completion statistics for a survey
router.get(
  '/surveys/:surveyId/stats',
  surveyProgressController.getCompletionStats
);

// Get current user's progress across all surveys
router.get(
  '/my-progress',
  surveyProgressController.getMyProgress
);

module.exports = router;

File: routes\user.js
----------------------------------------
const express = require('express');
const router = express.Router();
const { userController } = require('../bootstrap');
const auth = require('../middleware/auth');
const { 
  validateUserRegister, 
  validateUserLogin 
} = require('../middleware/validation');

router.post('/register', validateUserRegister, userController.registerUser);
router.post('/login', validateUserLogin, userController.loginUser);
router.get('/me', auth, userController.getCurrentUser);

module.exports = router;

File: script.js
----------------------------------------
const fs = require('fs');
const path = require('path');

var num = 0;

// Directory to start scanning
const startDir = './'; // Change this to your starting directory if needed
const outputFilePath = 'output.txt';

// Function to get all .js files from a directory recursively
function getAllJsFiles(dir, fileList = []) {
  const files = fs.readdirSync(dir);

  files.forEach((file) => {
    const filePath = path.join(dir, file);
    const stat = fs.statSync(filePath);

    if (stat.isDirectory() && file !== 'node_modules') {
      getAllJsFiles(filePath, fileList);
    } else if (path.extname(file) === '.js') {
      fileList.push(filePath);
    }
  });

  return fileList;
}

// Function to write all .js file names, paths, and content to a .txt file
function writeJsFilesToTxt(jsFiles, outputFile) {
  const writeStream = fs.createWriteStream(outputFile);

  jsFiles.forEach((filePath) => {
    const content = fs.readFileSync(filePath, 'utf8');
    writeStream.write(`File: ${filePath}\n`);
    writeStream.write('----------------------------------------\n');
    writeStream.write(`${content}\n\n`);
    num  = num +1;
  });


  writeStream.end();
}

// Main process
try {
  const jsFiles = getAllJsFiles(startDir);
  writeJsFilesToTxt(jsFiles, outputFilePath);
  console.log(`All JavaScript files have been written to ${outputFilePath}`);
  console.log(num);
} catch (err) {
  console.error('Error:', err);
}

File: service\answer.js
----------------------------------------
// services/answer.js
const BaseService = require('./baseService');
const CustomError = require('../utils/customError');

class AnswerService extends BaseService {
  constructor(answerRepository, questionService, surveyService) {
    super(answerRepository);
    this.questionService = questionService;
    this.surveyService = surveyService;
  }

  async createAnswer(data) {
    const question = await this.questionService.findById(data.questionId);
    if (!question) {
      throw new CustomError('Question not found', 404);
    }

    await this.questionService.validateQuestionType(question._id, data.answerValue);

    // Check if answer already exists
    const existingAnswer = await this.repository.findOne({
      questionId: data.questionId,
      respondentId: data.respondentId
    });

    if (existingAnswer) {
      throw new CustomError('Answer already exists for this question', 400);
    }

    const answer = await this.create({
      ...data,
      surveyId: question.surveyId,
      isValid: true,
      validatedAt: new Date()
    });

    return answer;
  }

  async getAnswersBySurvey(surveyId, userId) {
    const survey = await this.surveyService.findById(surveyId);
    if (!survey) {
      throw new CustomError('Survey not found', 404);
    }

    // Only creator and admin can see all answers
    if (survey.createdBy.toString() !== userId && userId.role !== 'admin') {
      throw new CustomError('Not authorized to view all answers', 403);
    }

    return await this.repository.findBySurveyAndRespondent(surveyId);
  }

  async getAnswersByQuestion(questionId) {
    const question = await this.questionService.findById(questionId);
    if (!question) {
      throw new CustomError('Question not found', 404);
    }

    return await this.repository.findQuestionAnswers(questionId);
  }

  async getRespondentAnswers(surveyId, respondentId) {
    const survey = await this.surveyService.findById(surveyId);
    if (!survey) {
      throw new CustomError('Survey not found', 404);
    }

    return await this.repository.findBySurveyAndRespondent(surveyId, respondentId);
  }

  async getSurveyStats(surveyId) {
    const survey = await this.surveyService.findById(surveyId);
    if (!survey) {
      throw new CustomError('Survey not found', 404);
    }

    const answers = await this.repository.findAll({ surveyId });
    const questionStats = {};

    answers.forEach(answer => {
      if (!questionStats[answer.questionId]) {
        questionStats[answer.questionId] = {
          totalAnswers: 0,
          answerDistribution: {}
        };
      }

      questionStats[answer.questionId].totalAnswers++;

      const value = Array.isArray(answer.answerValue) ? 
        answer.answerValue.join(', ') : 
        answer.answerValue.toString();

      questionStats[answer.questionId].answerDistribution[value] = 
        (questionStats[answer.questionId].answerDistribution[value] || 0) + 1;
    });

    return questionStats;
  }

  async deleteAnswer(answerId, userId, userRole) {
    const answer = await this.findById(answerId);
    if (!answer) {
      throw new CustomError('Answer not found', 404);
    }

    // Only answer creator or admin can delete
    if (answer.respondentId.toString() !== userId && userRole !== 'admin') {
      throw new CustomError('Not authorized to delete this answer', 403);
    }

    return await this.deleteById(answerId);
  }
}

module.exports = AnswerService;

File: service\baseService.js
----------------------------------------
const CustomError = require('../utils/customError');

class BaseService {
  constructor(repository) {
    this.repository = repository;
  }

  async create(data) {
    return await this.repository.create(data);
  }

  async findById(id, populate = '') {
    const item = await this.repository.findById(id, populate);
    if (!item) {
      throw new CustomError('Resource not found', 404);
    }
    return item;
  }

  async findAll(filter = {}, options = {}) {
    return await this.repository.findAll(filter, options);
  }

  async updateById(id, data) {
    const item = await this.repository.updateById(id, data);
    if (!item) {
      throw new CustomError('Resource not found', 404);
    }
    return item;
  }

  async deleteById(id) {
    const item = await this.repository.deleteById(id);
    if (!item) {
      throw new CustomError('Resource not found', 404);
    }
    return item;
  }
}

module.exports = BaseService;

File: service\question.js
----------------------------------------
const BaseService = require('./baseService');
const CustomError = require('../utils/customError');

class QuestionService extends BaseService {
  constructor(questionRepository, surveyService) {
    super(questionRepository);
    this.surveyService = surveyService;
  }

  async createQuestion(data) {
    const maxOrder = await this.repository.getMaxOrder(data.surveyId);
    const questionData = {
      ...data,
      order: maxOrder + 1
    };

    const question = await this.create(questionData);

    await this.surveyService.addQuestionToSurvey(question.surveyId, question._id);

    return question;
  }

  async getQuestionById(questionId) {
    const question = await this.findById(questionId);
    if (!question) {
      throw new CustomError('Question not found', 404);
    }
    return question;
  }

  async updateQuestion(questionId, data) {
    const question = await this.findById(questionId);
    if (!question) {
      throw new CustomError('Question not found', 404);
    }

    if (data.responseValues && 
        (question.responseType === 'multiple-choice' || 
         question.responseType === 'single-choice')) {
      if (data.responseValues.length < 2) {
        throw new CustomError('Choice questions must have at least 2 options', 400);
      }
      data.responseValues = data.responseValues.map((value, index) => ({
        value,
        order: index
      }));
    }

    const updateData = {
      ...data,
      responseType: undefined,
      surveyId: undefined,
      order: undefined
    };

    return await this.updateById(questionId, updateData);
  }

  async deleteQuestion(questionId) {
    const question = await this.findById(questionId);
    if (!question) {
      throw new CustomError('Question not found', 404);
    }

    await this.surveyService.removeQuestionFromSurvey(question.surveyId, questionId);

    await this.deleteById(questionId);

    await this.reorderQuestionsAfterDelete(question.surveyId, question.order);

    return question;
  }

  async deleteQuestionsBySurveyId(surveyId) {
    const questions = await this.findAll({ surveyId });
    for (const question of questions) {
      await this.deleteById(question._id);
    }
  }

  async moveQuestion(surveyId, questionId, direction) {
    const survey = await this.surveyService.findById(surveyId);
    if (!survey) {
      throw new CustomError('Survey not found', 404);
    }

    const question = await this.findById(questionId);
    if (!question) {
      throw new CustomError('Question not found', 404);
    }

    const currentOrder = question.order;
    const questions = await this.findAll({ 
      surveyId, 
      order: direction === 'up' ? currentOrder - 1 : currentOrder + 1 
    });

    if (questions.length === 0) {
      throw new CustomError(`Cannot move question ${direction}`, 400);
    }

    const otherQuestion = questions[0];

    await this.updateById(question._id, { order: otherQuestion.order });
    await this.updateById(otherQuestion._id, { order: currentOrder });

    const updatedQuestions = await this.findAll(
      { surveyId }, 
      { sort: { order: 1 } }
    );
    
    await this.surveyService.reorderQuestions(
      surveyId,
      updatedQuestions.map(q => q._id)
    );

    return await this.surveyService.findById(surveyId);
  }

  async reorderQuestionsAfterDelete(surveyId, deletedOrder) {
    const questionsToReorder = await this.findAll({
      surveyId,
      order: { $gt: deletedOrder }
    });

    for (const question of questionsToReorder) {
      await this.updateById(question._id, {
        order: question.order - 1
      });
    }
  }

  async duplicateQuestion(questionId, newSurveyId, userId) {
    const originalQuestion = await this.findById(questionId);
    if (!originalQuestion) {
      throw new CustomError('Question not found', 404);
    }

    const maxOrder = await this.repository.getMaxOrder(newSurveyId);

    const questionData = {
      surveyId: newSurveyId,
      questionText: originalQuestion.questionText,
      responseType: originalQuestion.responseType,
      responseValues: originalQuestion.responseValues,
      allowMultiple: originalQuestion.allowMultiple,
      isMandatory: originalQuestion.isMandatory,
      order: maxOrder + 1,
      createdBy: userId
    };

    return await this.create(questionData);
  }

  async validateQuestionType(questionId, answerValue) {
    const question = await this.findById(questionId);
    if (!question) {
      throw new CustomError('Question not found', 404);
    }

    switch (question.responseType) {
      case 'text':
        if (typeof answerValue !== 'string') {
          throw new CustomError('Answer must be a text value', 400);
        }
        break;

      case 'multiple-choice':
        if (!Array.isArray(answerValue)) {
          throw new CustomError('Answer must be an array for multiple-choice questions', 400);
        }
        if (!question.allowMultiple && answerValue.length > 1) {
          throw new CustomError('Multiple selections not allowed for this question', 400);
        }
        const validValues = question.responseValues.map(rv => rv.value);
        const invalidValues = answerValue.filter(v => !validValues.includes(v));
        if (invalidValues.length > 0) {
          throw new CustomError(`Invalid options selected: ${invalidValues.join(', ')}`, 400);
        }
        break;

      case 'single-choice':
        if (Array.isArray(answerValue)) {
          throw new CustomError('Single choice question cannot have multiple answers', 400);
        }
        if (!question.responseValues.some(rv => rv.value === answerValue)) {
          throw new CustomError('Invalid option selected', 400);
        }
        break;

      case 'rating':
        const rating = Number(answerValue);
        if (isNaN(rating) || rating < 1 || rating > 5) {
          throw new CustomError('Rating must be a number between 1 and 5', 400);
        }
        break;

      case 'boolean':
        if (typeof answerValue !== 'boolean') {
          throw new CustomError('Answer must be true or false', 400);
        }
        break;

      default:
        throw new CustomError('Invalid question type', 400);
    }

    return true;
  }
}

module.exports = QuestionService;

File: service\survey.js
----------------------------------------
const BaseService = require('./baseService');
const CustomError = require('../utils/customError');

class SurveyService extends BaseService {
    constructor(surveyRepository) {
      super(surveyRepository);
      this._questionService = null;
    }
  
    setQuestionService(questionService) {
      this._questionService = questionService;
    }
  
    async createSurvey(data) {
      const survey = await this.create({
        ...data,
        questions: [],
        questionOrder: []
      });
      return survey;
    }
  
    async getSurveyById(id) {
      const survey = await this.repository.findByIdWithQuestions(id);
      if (!survey) {
        throw new CustomError('Survey not found', 404);
      }
      return survey;
    }
  
    async getAllSurveys(filter = {}) {
      return await this.repository.findAllWithQuestions(filter);
    }
  
    async addQuestionToSurvey(surveyId, questionId) {
      const survey = await this.findById(surveyId);
      if (!survey.questions.includes(questionId)) {
        survey.questions.push(questionId);
        survey.questionOrder.push(questionId);
        await survey.save();
      }
      return survey;
    }
  
    async reorderQuestions(surveyId, questionOrder) {
      const survey = await this.findById(surveyId);
      const currentQuestions = new Set(survey.questions.map(q => q.toString()));
      
      if (!questionOrder.every(id => currentQuestions.has(id.toString()))) {
        throw new CustomError('Invalid question order provided', 400);
      }
  
      survey.questionOrder = questionOrder;
      await this._questionService.repository.reorderQuestions(surveyId, questionOrder);
      await survey.save();
      return survey;
    }
  
    async archiveSurvey(id, userId) {
      return await this.updateById(id, {
        isArchived: true,
        archivedAt: new Date(),
        modifiedBy: userId
      });
    }
  
    async unarchiveSurvey(id, userId) {
      return await this.updateById(id, {
        isArchived: false,
        archivedAt: null,
        modifiedBy: userId
      });
    }
  
    async duplicateSurvey(id, userId) {
      const originalSurvey = await this.getSurveyById(id);
      const surveyData = {
        title: `${originalSurvey.title} (Copy)`,
        description: originalSurvey.description,
        isTemplate: originalSurvey.isTemplate,
        createdBy: userId
      };
  
      const newSurvey = await this.createSurvey(surveyData);
  
      for (const question of originalSurvey.questions) {
        const newQuestion = await this._questionService.duplicateQuestion(
          question._id,
          newSurvey._id,
          userId
        );
        await this.addQuestionToSurvey(newSurvey._id, newQuestion._id);
      }
  
      return await this.getSurveyById(newSurvey._id);
    }

    async removeQuestionFromSurvey(surveyId, questionId) {
        const survey = await this.findById(surveyId);
        if (!survey) {
          throw new CustomError('Survey not found', 404);
        }
      
        survey.questions = survey.questions.filter(id => id.toString() !== questionId.toString());
        survey.questionOrder = survey.questionOrder.filter(id => id.toString() !== questionId.toString());
        
        await survey.save();
        return survey;
      }

  }
  
  module.exports = SurveyService;

File: service\surveyProgress.js
----------------------------------------
// services/surveyProgress.js
const BaseService = require('./baseService');
const CustomError = require('../utils/customError');

class SurveyProgressService extends BaseService {
  constructor(surveyProgressRepository, surveyService, questionService) {
    super(surveyProgressRepository);
    this.surveyService = surveyService;
    this.questionService = questionService;
  }

  async initializeProgress(surveyId, respondentId) {
    // Verify survey exists
    const survey = await this.surveyService.findById(surveyId);
    if (!survey) {
      throw new CustomError('Survey not found', 404);
    }

    // Check for existing progress
    let progress = await this.repository.findBySurveyAndRespondent(
      surveyId,
      respondentId
    );

    if (!progress) {
      progress = await this.create({
        surveyId,
        respondentId,
        status: 'NOT_STARTED',
        progress: 0,
        answeredQuestions: []
      });
    }

    return progress;
  }

  async updateProgress(surveyId, respondentId, questionId) {
    const survey = await this.surveyService.findById(surveyId);
    if (!survey) {
      throw new CustomError('Survey not found', 404);
    }

    const question = await this.questionService.findById(questionId);
    if (!question || question.surveyId.toString() !== surveyId) {
      throw new CustomError('Question not found in this survey', 404);
    }

    const progress = await this.repository.findBySurveyAndRespondent(
      surveyId,
      respondentId
    );

    if (!progress) {
      throw new CustomError('Survey progress not found for this survey', 404);
    }

    if (progress.status === 'NOT_STARTED') {
      progress.status = 'IN_PROGRESS';
    }

    if (!progress.answeredQuestions.includes(questionId)) {
      progress.answeredQuestions.push(questionId);
    }

    progress.progress = (progress.answeredQuestions.length / survey.questions.length) * 100;

    if (progress.progress === 100) {
      progress.status = 'COMPLETED';
    }

    await progress.save();
    return progress;
  }

  async updateBulkProgress(surveyId, respondentId, questionIds) {
    if (!Array.isArray(questionIds)) {
        throw new CustomError('questionIds must be an array', 400);
    }

    if (questionIds.length === 0) {
        throw new CustomError('questionIds array cannot be empty', 400);
    }

    const survey = await this.surveyService.findById(surveyId);
    if (!survey) {
        throw new CustomError('Survey not found', 404);
    }

    const surveyQuestionIds = survey.questions.map(q => q.toString());
    const invalidQuestions = questionIds.filter(qId => !surveyQuestionIds.includes(qId.toString()));
    if (invalidQuestions.length > 0) {
        throw new CustomError(
            `Questions with IDs: ${invalidQuestions.join(', ')} do not belong to this survey`,
            400
        );
    }

    const progress = await this.repository.findBySurveyAndRespondent(surveyId, respondentId);
    if (!progress) {
        throw new CustomError(
            `No survey progress found for user ${respondentId} on survey ${surveyId}`,
            404
        );
    }

    try {
        if (progress.status === 'NOT_STARTED') {
            progress.status = 'IN_PROGRESS';
        }

        const uniqueQuestionIds = new Set([
            ...progress.answeredQuestions.map(q => q.toString()),
            ...questionIds.map(q => q.toString())
        ]);
        progress.answeredQuestions = Array.from(uniqueQuestionIds);

        progress.progress = Math.min(
            (progress.answeredQuestions.length / survey.questions.length) * 100,
            100
        );

        if (progress.progress === 100) {
            progress.status = 'COMPLETED';
            progress.completedAt = new Date();
        }

        progress.lastAnsweredAt = new Date();

        await progress.save();
        return progress;
    } catch (error) {
        throw new CustomError(
            `Failed to update progress: ${error.message}`,
            500
        );
    }
}
  

  async getProgress(surveyId, respondentId) {
    const survey = await this.surveyService.findById(surveyId);
    if (!survey) {
      throw new CustomError('Survey not found', 404);
    }

    const progress = await this.repository.findBySurveyAndRespondent(
      surveyId,
      respondentId
    );

    if (!progress) {
      throw new CustomError('Survey progress not found', 404);
    }

    return progress;
  }

  async getSurveyParticipants(surveyId, requesterId) {
    const survey = await this.surveyService.findById(surveyId);
    if (!survey) {
      throw new CustomError('Survey not found', 404);
    }

    if (survey.createdBy.toString() !== requesterId && requesterId.role !== 'admin') {
      throw new CustomError('Not authorized to view participants', 403);
    }

    return await this.repository.findBySurveyWithRespondents(surveyId);
  }

  async getCompletionStats(surveyId, requesterId) {
    const survey = await this.surveyService.findById(surveyId);
    if (!survey) {
      throw new CustomError('Survey not found', 404);
    }

    if (survey.createdBy.toString() !== requesterId && requesterId.role !== 'admin') {
      throw new CustomError('Not authorized to view statistics', 403);
    }

    return await this.repository.getCompletionStats(surveyId);
  }

  async getRespondentProgress(respondentId) {
    return await this.repository.getRespondentProgress(respondentId);
  }
}

module.exports = SurveyProgressService;

File: service\user.js
----------------------------------------
const BaseService = require('./baseService');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const keys = require('../config/keys');
const CustomError = require('../utils/customError');

class UserService extends BaseService {
  constructor(repository) {
    super(repository);
  }

  async registerUser(userData) {
    const { username, password } = userData;
    let user = await this.repository.findByUsername(username);
    if (user) {
      throw new CustomError(`User with username ${username} already exists`, 400);
    }
    const hashedPassword = await bcrypt.hash(password, 10);
    const newUser = await this.repository.create({
      username,
      password: hashedPassword,
    });
    const token = jwt.sign({ id: newUser._id }, keys.jwtSecret, {
      expiresIn: '1d',
    });
    return { user: { id: newUser._id, username: newUser.username }, token };
  }

  async loginUser(userData) {
    const { username, password } = userData;
    let user = await this.repository.findByUsername(username);
    if (!user) {
      throw new CustomError('Invalid user details', 400);
    }
    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) {
      throw new CustomError('Wrong password', 400);
    }
    const token = jwt.sign({ id: user._id }, keys.jwtSecret, { expiresIn: '1d' });
    return { user: { id: user._id, username: user.username }, token };
  }

  async getUserById(userId) {
    const user = await this.findById(userId);
    if (!user) {
      throw new CustomError('User not found', 404);
    }
    return user;
  }
}

module.exports = UserService;


File: utils\customError.js
----------------------------------------
class CustomError extends Error {
  constructor(message, statusCode) {
    super(message);
    this.statusCode = statusCode;
    this.status = `${statusCode}`.startsWith('4') ? 'fail' : 'error';
    this.isOperational = true;

    Error.captureStackTrace(this, this.constructor);
  }
}

module.exports = CustomError;

File: utils\formatResponse.js
----------------------------------------
const formatResponse = (data, message = '') => {
  return {
    success: true,
    message,
    data
  };
};

module.exports = formatResponse;
  

File: utils\generateToken.js
----------------------------------------
const jwt = require('jsonwebtoken');
const keys = require('../config/keys');

const generateToken = (userId) => {
  return jwt.sign(
    { id: userId },
    keys.jwtSecret,
    { expiresIn: '1d' }
  );
};

module.exports = generateToken;

